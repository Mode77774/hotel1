"use strict";
function _class_call_check(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
    }
}
function _defineProperties(target, props) {
    for(var i = 0; i < props.length; i++){
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
    }
}
function _create_class(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties(Constructor, staticProps);
    return Constructor;
}
function _define_property(obj, key, value) {
    if (key in obj) {
        Object.defineProperty(obj, key, {
            value: value,
            enumerable: true,
            configurable: true,
            writable: true
        });
    } else {
        obj[key] = value;
    }
    return obj;
}
function _instanceof(left, right) {
    if (right != null && typeof Symbol !== "undefined" && right[Symbol.hasInstance]) {
        return !!right[Symbol.hasInstance](left);
    } else {
        return left instanceof right;
    }
}
function _object_spread(target) {
    for(var i = 1; i < arguments.length; i++){
        var source = arguments[i] != null ? arguments[i] : {};
        var ownKeys = Object.keys(source);
        if (typeof Object.getOwnPropertySymbols === "function") {
            ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {
                return Object.getOwnPropertyDescriptor(source, sym).enumerable;
            }));
        }
        ownKeys.forEach(function(key) {
            _define_property(target, key, source[key]);
        });
    }
    return target;
}
function _type_of(obj) {
    "@swc/helpers - typeof";
    return obj && typeof Symbol !== "undefined" && obj.constructor === Symbol ? "symbol" : typeof obj;
}
(function() {
    var c = function c(t2) {
        if ("string" != typeof t2 && (t2 = String(t2)), /[^a-z0-9\-#$%&'*+.^_`|~!]/i.test(t2) || "" === t2) throw new TypeError('Invalid character in header field name: "' + t2 + '"');
        return t2.toLowerCase();
    };
    var l = function l(t2) {
        return "string" != typeof t2 && (t2 = String(t2)), t2;
    };
    var h = function h(t2) {
        var e2 = {
            next: function next() {
                var e3 = t2.shift();
                return {
                    done: void 0 === e3,
                    value: e3
                };
            }
        };
        return n && (e2[Symbol.iterator] = function() {
            return e2;
        }), e2;
    };
    var f = function f(t2) {
        if (t2.bodyUsed) return Promise.reject(new TypeError("Already read"));
        t2.bodyUsed = true;
    };
    var p = function p(t2) {
        return new Promise(function(e2, r2) {
            t2.onload = function() {
                e2(t2.result);
            }, t2.onerror = function() {
                r2(t2.error);
            };
        });
    };
    var y = function y(t2) {
        var e2 = new FileReader(), r2 = p(e2);
        return e2.readAsArrayBuffer(t2), r2;
    };
    var b = function b(t2) {
        if (t2.slice) return t2.slice(0);
        var e2 = new Uint8Array(t2.byteLength);
        return e2.set(new Uint8Array(t2)), e2.buffer;
    };
    var v = function v() {
        return this.bodyUsed = false, this._initBody = function(t2) {
            var e2;
            this.bodyUsed = this.bodyUsed, this._bodyInit = t2, t2 ? "string" == typeof t2 ? this._bodyText = t2 : i && Blob.prototype.isPrototypeOf(t2) ? this._bodyBlob = t2 : o && FormData.prototype.isPrototypeOf(t2) ? this._bodyFormData = t2 : r && URLSearchParams.prototype.isPrototypeOf(t2) ? this._bodyText = t2.toString() : s && i && (e2 = t2) && DataView.prototype.isPrototypeOf(e2) ? (this._bodyArrayBuffer = b(t2.buffer), this._bodyInit = new Blob([
                this._bodyArrayBuffer
            ])) : s && (ArrayBuffer.prototype.isPrototypeOf(t2) || u(t2)) ? this._bodyArrayBuffer = b(t2) : this._bodyText = t2 = Object.prototype.toString.call(t2) : this._bodyText = "", this.headers.get("content-type") || ("string" == typeof t2 ? this.headers.set("content-type", "text/plain;charset=UTF-8") : this._bodyBlob && this._bodyBlob.type ? this.headers.set("content-type", this._bodyBlob.type) : r && URLSearchParams.prototype.isPrototypeOf(t2) && this.headers.set("content-type", "application/x-www-form-urlencoded;charset=UTF-8"));
        }, i && (this.blob = function() {
            var t2 = f(this);
            if (t2) return t2;
            if (this._bodyBlob) return Promise.resolve(this._bodyBlob);
            if (this._bodyArrayBuffer) return Promise.resolve(new Blob([
                this._bodyArrayBuffer
            ]));
            if (this._bodyFormData) throw new Error("could not read FormData body as blob");
            return Promise.resolve(new Blob([
                this._bodyText
            ]));
        }, this.arrayBuffer = function() {
            if (this._bodyArrayBuffer) {
                var t2 = f(this);
                return t2 || (ArrayBuffer.isView(this._bodyArrayBuffer) ? Promise.resolve(this._bodyArrayBuffer.buffer.slice(this._bodyArrayBuffer.byteOffset, this._bodyArrayBuffer.byteOffset + this._bodyArrayBuffer.byteLength)) : Promise.resolve(this._bodyArrayBuffer));
            }
            return this.blob().then(y);
        }), this.text = function() {
            var t2, e2, r2, n2 = f(this);
            if (n2) return n2;
            if (this._bodyBlob) return t2 = this._bodyBlob, e2 = new FileReader(), r2 = p(e2), e2.readAsText(t2), r2;
            if (this._bodyArrayBuffer) return Promise.resolve(function(t3) {
                for(var e3 = new Uint8Array(t3), r3 = new Array(e3.length), n3 = 0; n3 < e3.length; n3++)r3[n3] = String.fromCharCode(e3[n3]);
                return r3.join("");
            }(this._bodyArrayBuffer));
            if (this._bodyFormData) throw new Error("could not read FormData body as text");
            return Promise.resolve(this._bodyText);
        }, o && (this.formData = function() {
            return this.text().then(E);
        }), this.json = function() {
            return this.text().then(JSON.parse);
        }, this;
    };
    var E = function E(t2) {
        var e2 = new FormData();
        return t2.trim().split("&").forEach(function(t3) {
            if (t3) {
                var r2 = t3.split("="), n2 = r2.shift().replace(/\+/g, " "), i2 = r2.join("=").replace(/\+/g, " ");
                e2.append(decodeURIComponent(n2), decodeURIComponent(i2));
            }
        }), e2;
    };
    var T = function T(t2, r2) {
        return new Promise(function(n2, o2) {
            var a2 = new R(t2, r2);
            if (a2.signal && a2.signal.aborted) return o2(new _("Aborted", "AbortError"));
            var u2 = new XMLHttpRequest();
            function c2() {
                u2.abort();
            }
            u2.onload = function() {
                var t3, e2, r3 = {
                    status: u2.status,
                    statusText: u2.statusText,
                    headers: (t3 = u2.getAllResponseHeaders() || "", e2 = new d(), t3.replace(/\r?\n[\t ]+/g, " ").split("\r").map(function(t4) {
                        return 0 === t4.indexOf("\n") ? t4.substr(1, t4.length) : t4;
                    }).forEach(function(t4) {
                        var r4 = t4.split(":"), n3 = r4.shift().trim();
                        if (n3) {
                            var i3 = r4.join(":").trim();
                            e2.append(n3, i3);
                        }
                    }), e2)
                };
                r3.url = "responseURL" in u2 ? u2.responseURL : r3.headers.get("X-Request-URL");
                var i2 = "response" in u2 ? u2.response : u2.responseText;
                setTimeout(function() {
                    n2(new w(i2, r3));
                }, 0);
            }, u2.onerror = function() {
                setTimeout(function() {
                    o2(new TypeError("Network request failed"));
                }, 0);
            }, u2.ontimeout = function() {
                setTimeout(function() {
                    o2(new TypeError("Network request failed"));
                }, 0);
            }, u2.onabort = function() {
                setTimeout(function() {
                    o2(new _("Aborted", "AbortError"));
                }, 0);
            }, u2.open(a2.method, function(t3) {
                try {
                    return "" === t3 && e.location.href ? e.location.href : t3;
                } catch (e2) {
                    return t3;
                }
            }(a2.url), true), "include" === a2.credentials ? u2.withCredentials = true : "omit" === a2.credentials && (u2.withCredentials = false), "responseType" in u2 && (i ? u2.responseType = "blob" : s && a2.headers.get("Content-Type") && -1 !== a2.headers.get("Content-Type").indexOf("application/octet-stream") && (u2.responseType = "arraybuffer")), !r2 || "object" != typeof r2.headers || _instanceof(r2.headers, d) ? a2.headers.forEach(function(t3, e2) {
                u2.setRequestHeader(e2, t3);
            }) : Object.getOwnPropertyNames(r2.headers).forEach(function(t3) {
                u2.setRequestHeader(t3, l(r2.headers[t3]));
            }), a2.signal && (a2.signal.addEventListener("abort", c2), u2.onreadystatechange = function() {
                4 === u2.readyState && a2.signal.removeEventListener("abort", c2);
            }), u2.send(void 0 === a2._bodyInit ? null : a2._bodyInit);
        });
    };
    var P = function P(t2, e2, r2, n2) {
        return new (r2 || (r2 = Promise))(function(i2, o2) {
            function s2(t3) {
                try {
                    u2(n2.next(t3));
                } catch (t4) {
                    o2(t4);
                }
            }
            function a2(t3) {
                try {
                    u2(n2.throw(t3));
                } catch (t4) {
                    o2(t4);
                }
            }
            function u2(t3) {
                var e3;
                t3.done ? i2(t3.value) : (e3 = t3.value, _instanceof(e3, r2) ? e3 : new r2(function(t4) {
                    t4(e3);
                })).then(s2, a2);
            }
            u2((n2 = n2.apply(t2, e2 || [])).next());
        });
    };
    var k = function k(t2, e2) {
        var r2, n2, i2, o2, s2 = {
            label: 0,
            sent: function sent() {
                if (1 & i2[0]) throw i2[1];
                return i2[1];
            },
            trys: [],
            ops: []
        };
        return o2 = {
            next: a2(0),
            throw: a2(1),
            return: a2(2)
        }, "function" == typeof Symbol && (o2[Symbol.iterator] = function() {
            return this;
        }), o2;
        function a2(a3) {
            return function(u2) {
                return function(a4) {
                    if (r2) throw new TypeError("Generator is already executing.");
                    for(; o2 && (o2 = 0, a4[0] && (s2 = 0)), s2;)try {
                        if (r2 = 1, n2 && (i2 = 2 & a4[0] ? n2.return : a4[0] ? n2.throw || ((i2 = n2.return) && i2.call(n2), 0) : n2.next) && !(i2 = i2.call(n2, a4[1])).done) return i2;
                        switch(n2 = 0, i2 && (a4 = [
                            2 & a4[0],
                            i2.value
                        ]), a4[0]){
                            case 0:
                            case 1:
                                i2 = a4;
                                break;
                            case 4:
                                return s2.label++, {
                                    value: a4[1],
                                    done: false
                                };
                            case 5:
                                s2.label++, n2 = a4[1], a4 = [
                                    0
                                ];
                                continue;
                            case 7:
                                a4 = s2.ops.pop(), s2.trys.pop();
                                continue;
                            default:
                                if (!(i2 = s2.trys, (i2 = i2.length > 0 && i2[i2.length - 1]) || 6 !== a4[0] && 2 !== a4[0])) {
                                    s2 = 0;
                                    continue;
                                }
                                if (3 === a4[0] && (!i2 || a4[1] > i2[0] && a4[1] < i2[3])) {
                                    s2.label = a4[1];
                                    break;
                                }
                                if (6 === a4[0] && s2.label < i2[1]) {
                                    s2.label = i2[1], i2 = a4;
                                    break;
                                }
                                if (i2 && s2.label < i2[2]) {
                                    s2.label = i2[2], s2.ops.push(a4);
                                    break;
                                }
                                i2[2] && s2.ops.pop(), s2.trys.pop();
                                continue;
                        }
                        a4 = e2.call(t2, s2);
                    } catch (t3) {
                        a4 = [
                            6,
                            t3
                        ], n2 = 0;
                    } finally{
                        r2 = i2 = 0;
                    }
                    if (5 & a4[0]) throw a4[1];
                    return {
                        value: a4[0] ? a4[1] : void 0,
                        done: true
                    };
                }([
                    a3,
                    u2
                ]);
            };
        }
    };
    var S = function S(t2) {
        for(var e2 = "", r2 = 0; r2 < t2.length; ++r2)if (r2 > 0) {
            var n2 = t2[r2].toLowerCase();
            n2 !== t2[r2] ? e2 += " ".concat(n2) : e2 += t2[r2];
        } else e2 += t2[r2].toUpperCase();
        return e2;
    };
    var M = function M(t2, e2) {
        var r2 = [];
        return (function(t3, e3) {
            var r3, n2, i2 = (n2 = function(t4, e4, r4) {
                if (r4 || 2 === arguments.length) for(var n3, i3 = 0, o3 = e4.length; i3 < o3; i3++)!n3 && i3 in e4 || (n3 || (n3 = Array.prototype.slice.call(e4, 0, i3)), n3[i3] = e4[i3]);
                return t4.concat(n3 || Array.prototype.slice.call(e4));
            }([], t3, true), {
                current: function current() {
                    return n2[0];
                },
                postpone: function postpone() {
                    var t4 = n2.shift();
                    void 0 !== t4 && n2.push(t4);
                },
                exclude: function exclude() {
                    n2.shift();
                }
            }), o2 = (r3 = 0, function o2() {
                return Math.random() * Math.min(3e3, 100 * Math.pow(2, r3++));
            }), s2 = i2.current();
            if (void 0 === s2) return Promise.reject(new TypeError("The list of script URL patterns is empty"));
            var a2 = function a21(t4, r4) {
                return e3(t4).catch(function(t5) {
                    if (r4 + 1 >= 5) throw t5;
                    !function(t6) {
                        if (!_instanceof(t6, Error)) return false;
                        var e5 = t6.message;
                        return e5 === B || e5 === L;
                    }(t5) ? i2.postpone() : i2.exclude();
                    var e4, n3 = i2.current();
                    if (void 0 === n3) throw t5;
                    return (e4 = o2(), new Promise(function(t6) {
                        return setTimeout(t6, e4);
                    })).then(function() {
                        return a2(n3, r4 + 1);
                    });
                });
            };
            return a2(s2, 0);
        })(t2, function(t3) {
            var n2 = /* @__PURE__ */ new Date(), i2 = function i2(e3) {
                return r2.push({
                    url: t3,
                    startedAt: n2,
                    finishedAt: /* @__PURE__ */ new Date(),
                    error: e3
                });
            }, o2 = e2(t3);
            return o2.then(function() {
                return i2();
            }, i2), o2;
        }).then(function(t3) {
            return [
                t3,
                {
                    attempts: r2
                }
            ];
        });
    };
    var H = function H(t2) {
        return (function(t3, e2, r2, n2) {
            var i2, o2 = document, s2 = "securitypolicyviolation", a2 = function a2(e3) {
                var r3 = new URL(t3, location.href), n3 = e3.blockedURI;
                n3 !== r3.href && n3 !== r3.protocol.slice(0, -1) && n3 !== r3.origin || (i2 = e3, u2());
            };
            o2.addEventListener(s2, a2);
            var u2 = function u2() {
                return o2.removeEventListener(s2, a2);
            };
            return Promise.resolve().then(e2).then(function(t4) {
                return u2(), t4;
            }, function(t4) {
                return new Promise(function(t5) {
                    return setTimeout(t5);
                }).then(function() {
                    if (u2(), i2) return function() {
                        throw new Error(B);
                    }();
                    throw t4;
                });
            });
        })(t2, function() {
            return function(t3) {
                return new Promise(function(e2, r2) {
                    var n2 = document.createElement("script"), i2 = function i2() {
                        var t4;
                        return null === (t4 = n2.parentNode) || void 0 === t4 ? void 0 : t4.removeChild(n2);
                    }, o2 = document.head || document.getElementsByTagName("head")[0];
                    n2.onload = function() {
                        i2(), e2();
                    }, n2.onerror = function() {
                        i2(), r2(new Error(J));
                    }, n2.async = true, n2.src = t3, o2.appendChild(n2);
                });
            }(t2);
        }).then(V);
    };
    var V = function V() {
        var t2 = window, e2 = "__fpjs_p_l_b", r2 = t2[e2];
        if (function(t3, e3) {
            var r3, n2 = null === (r3 = Object.getOwnPropertyDescriptor) || void 0 === r3 ? void 0 : r3.call(Object, t3, e3);
            (null == n2 ? void 0 : n2.configurable) ? delete t3[e3] : n2 && !n2.writable || (t3[e3] = void 0);
        }(t2, e2), "function" != typeof (null == r2 ? void 0 : r2.load)) throw new Error(L);
        return r2;
    };
    var G = function G(t2) {
        throw _instanceof(t2, Error) && t2.message === L ? new Error(J) : t2;
    };
    var Q = function Q(t2) {
        if (!_instanceof(t2, Error)) throw t2;
    };
    var performDraw = // ../../node_modules/.pnpm/@datadog+browser-core@4.42.2/node_modules/@datadog/browser-core/esm/tools/utils/numberUtils.js
    function performDraw(threshold) {
        return threshold !== 0 && Math.random() * 100 <= threshold;
    };
    var isPercentage = function isPercentage(value) {
        return isNumber(value) && value >= 0 && value <= 100;
    };
    var isNumber = function isNumber(value) {
        return typeof value === "number";
    };
    var dateNow = function dateNow() {
        return /* @__PURE__ */ new Date().getTime();
    };
    var timeStampNow = function timeStampNow() {
        return dateNow();
    };
    var relativeNow = function relativeNow() {
        return performance.now();
    };
    var clocksNow = function clocksNow() {
        return {
            relative: relativeNow(),
            timeStamp: timeStampNow()
        };
    };
    var clocksOrigin = function clocksOrigin() {
        return {
            relative: 0,
            timeStamp: getNavigationStart()
        };
    };
    var elapsed = function elapsed(start, end) {
        return end - start;
    };
    var getRelativeTime = function getRelativeTime(timestamp) {
        return timestamp - getNavigationStart();
    };
    var getNavigationStart = function getNavigationStart() {
        if (navigationStart === void 0) {
            navigationStart = performance.timing.navigationStart;
        }
        return navigationStart;
    };
    var findCommaSeparatedValue = function findCommaSeparatedValue(rawString, name) {
        var regex = new RegExp("(?:^|;)\\s*".concat(name, "\\s*=\\s*([^;]+)"));
        var matches = regex.exec(rawString);
        return matches ? matches[1] : void 0;
    };
    var safeTruncate = function safeTruncate(candidate, length, suffix) {
        if (suffix === void 0) {
            suffix = "";
        }
        var lastChar = candidate.charCodeAt(length - 1);
        var isLastCharSurrogatePair = lastChar >= 55296 && lastChar <= 56319;
        var correctedLength = isLastCharSurrogatePair ? length + 1 : length;
        if (candidate.length <= correctedLength) {
            return candidate;
        }
        return "".concat(candidate.slice(0, correctedLength)).concat(suffix);
    };
    var setCookie = function setCookie(name, value, expireDelay, options) {
        var date = /* @__PURE__ */ new Date();
        date.setTime(date.getTime() + expireDelay);
        var expires = "expires=".concat(date.toUTCString());
        var sameSite = options && options.crossSite ? "none" : "strict";
        var domain = options && options.domain ? ";domain=".concat(options.domain) : "";
        var secure = options && options.secure ? ";secure" : "";
        document.cookie = "".concat(name, "=").concat(value, ";").concat(expires, ";path=/;samesite=").concat(sameSite).concat(domain).concat(secure);
    };
    var getCookie = function getCookie(name) {
        return findCommaSeparatedValue(document.cookie, name);
    };
    var deleteCookie = function deleteCookie(name, options) {
        setCookie(name, "", 0, options);
    };
    var areCookiesAuthorized = function areCookiesAuthorized(options) {
        if (document.cookie === void 0 || document.cookie === null) {
            return false;
        }
        try {
            var testCookieName = "dd_cookie_test_".concat(generateUUID());
            var testCookieValue = "test";
            setCookie(testCookieName, testCookieValue, ONE_MINUTE, options);
            var isCookieCorrectlySet = getCookie(testCookieName) === testCookieValue;
            deleteCookie(testCookieName, options);
            return isCookieCorrectlySet;
        } catch (error) {
            display.error(error);
            return false;
        }
    };
    var getCurrentSite = function getCurrentSite() {
        if (getCurrentSiteCache === void 0) {
            var testCookieName = "dd_site_test_".concat(generateUUID());
            var testCookieValue = "test";
            var domainLevels = window.location.hostname.split(".");
            var candidateDomain = domainLevels.pop();
            while(domainLevels.length && !getCookie(testCookieName)){
                candidateDomain = "".concat(domainLevels.pop(), ".").concat(candidateDomain);
                setCookie(testCookieName, testCookieValue, ONE_SECOND, {
                    domain: candidateDomain
                });
            }
            deleteCookie(testCookieName, {
                domain: candidateDomain
            });
            getCurrentSiteCache = candidateDomain;
        }
        return getCurrentSiteCache;
    };
    var catchUserErrors = // ../../node_modules/.pnpm/@datadog+browser-core@4.42.2/node_modules/@datadog/browser-core/esm/tools/catchUserErrors.js
    function catchUserErrors(fn, errorMsg) {
        return function() {
            var args = [];
            for(var _i = 0; _i < arguments.length; _i++){
                args[_i] = arguments[_i];
            }
            try {
                return fn.apply(void 0, args);
            } catch (err) {
                display.error(errorMsg, err);
            }
        };
    };
    var addExperimentalFeatures = function addExperimentalFeatures(enabledFeatures) {
        enabledFeatures.forEach(function(flag) {
            enabledExperimentalFeatures.add(flag);
        });
    };
    var isExperimentalFeatureEnabled = function isExperimentalFeatureEnabled(featureName) {
        return enabledExperimentalFeatures.has(featureName);
    };
    var getExperimentalFeatures = function getExperimentalFeatures() {
        return enabledExperimentalFeatures;
    };
    var computeBytesCount = function computeBytesCount(candidate) {
        if (!HAS_MULTI_BYTES_CHARACTERS.test(candidate)) {
            return candidate.length;
        }
        if (window.TextEncoder !== void 0) {
            return new TextEncoder().encode(candidate).length;
        }
        return new Blob([
            candidate
        ]).size;
    };
    var includes = // ../../node_modules/.pnpm/@datadog+browser-core@4.42.2/node_modules/@datadog/browser-core/esm/tools/utils/polyfills.js
    function includes(candidate, search) {
        return candidate.indexOf(search) !== -1;
    };
    var arrayFrom = function arrayFrom(arrayLike) {
        if (Array.from) {
            return Array.from(arrayLike);
        }
        var array = [];
        if (_instanceof(arrayLike, Set)) {
            arrayLike.forEach(function(item) {
                return array.push(item);
            });
        } else {
            for(var i2 = 0; i2 < arrayLike.length; i2++){
                array.push(arrayLike[i2]);
            }
        }
        return array;
    };
    var find = function find(array, predicate) {
        for(var i2 = 0; i2 < array.length; i2 += 1){
            var item = array[i2];
            if (predicate(item, i2)) {
                return item;
            }
        }
        return void 0;
    };
    var objectValues = function objectValues(object) {
        return Object.keys(object).map(function(key) {
            return object[key];
        });
    };
    var objectEntries = function objectEntries(object) {
        return Object.keys(object).map(function(key) {
            return [
                key,
                object[key]
            ];
        });
    };
    var startsWith = function startsWith(candidate, search) {
        return candidate.slice(0, search.length) === search;
    };
    var endsWith = function endsWith(candidate, search) {
        return candidate.slice(-search.length) === search;
    };
    var assign = function assign(target) {
        var toAssign = [];
        for(var _i = 1; _i < arguments.length; _i++){
            toAssign[_i - 1] = arguments[_i];
        }
        toAssign.forEach(function(source) {
            for(var key in source){
                if (Object.prototype.hasOwnProperty.call(source, key)) {
                    target[key] = source[key];
                }
            }
        });
        return target;
    };
    var shallowClone = // ../../node_modules/.pnpm/@datadog+browser-core@4.42.2/node_modules/@datadog/browser-core/esm/tools/utils/objectUtils.js
    function shallowClone(object) {
        return assign({}, object);
    };
    var objectHasValue = function objectHasValue(object, value) {
        return Object.keys(object).some(function(key) {
            return object[key] === value;
        });
    };
    var isEmptyObject = function isEmptyObject(object) {
        return Object.keys(object).length === 0;
    };
    var getGlobalObject = // ../../node_modules/.pnpm/@datadog+browser-core@4.42.2/node_modules/@datadog/browser-core/esm/tools/getGlobalObject.js
    function getGlobalObject() {
        if (typeof globalThis === "object") {
            return globalThis;
        }
        Object.defineProperty(Object.prototype, "_dd_temp_", {
            get: function get() {
                return this;
            },
            configurable: true
        });
        var globalObject = _dd_temp_;
        delete Object.prototype._dd_temp_;
        if (typeof globalObject !== "object") {
            if (typeof self === "object") {
                globalObject = self;
            } else if (typeof window === "object") {
                globalObject = window;
            } else {
                globalObject = {};
            }
        }
        return globalObject;
    };
    var getZoneJsOriginalValue = // ../../node_modules/.pnpm/@datadog+browser-core@4.42.2/node_modules/@datadog/browser-core/esm/tools/getZoneJsOriginalValue.js
    function getZoneJsOriginalValue(target, name) {
        var browserWindow = getGlobalObject();
        var original;
        if (browserWindow.Zone && typeof browserWindow.Zone.__symbol__ === "function") {
            original = target[browserWindow.Zone.__symbol__(name)];
        }
        if (!original) {
            original = target[name];
        }
        return original;
    };
    var startMonitorErrorCollection = function startMonitorErrorCollection(newOnMonitorErrorCollected) {
        onMonitorErrorCollected = newOnMonitorErrorCollected;
    };
    var setDebugMode = function setDebugMode(newDebugMode) {
        debugMode = newDebugMode;
    };
    var monitored = function monitored(_2, __, descriptor) {
        var originalMethod = descriptor.value;
        descriptor.value = function() {
            var args = [];
            for(var _i = 0; _i < arguments.length; _i++){
                args[_i] = arguments[_i];
            }
            var decorated = onMonitorErrorCollected ? monitor(originalMethod) : originalMethod;
            return decorated.apply(this, args);
        };
    };
    var monitor = function monitor(fn) {
        return function() {
            return callMonitored(fn, this, arguments);
        };
    };
    var callMonitored = function callMonitored(fn, context, args) {
        try {
            return fn.apply(context, args);
        } catch (e2) {
            displayIfDebugEnabled(ConsoleApiName.error, e2);
            if (onMonitorErrorCollected) {
                try {
                    onMonitorErrorCollected(e2);
                } catch (e3) {
                    displayIfDebugEnabled(ConsoleApiName.error, e3);
                }
            }
        }
    };
    var displayIfDebugEnabled = function displayIfDebugEnabled(api) {
        var args = [];
        for(var _i = 1; _i < arguments.length; _i++){
            args[_i - 1] = arguments[_i];
        }
        if (debugMode) {
            display.apply(void 0, __spreadArray([
                api,
                "[MONITOR]"
            ], args, false));
        }
    };
    var setTimeout2 = // ../../node_modules/.pnpm/@datadog+browser-core@4.42.2/node_modules/@datadog/browser-core/esm/tools/timer.js
    function setTimeout2(callback, delay) {
        return getZoneJsOriginalValue(getGlobalObject(), "setTimeout")(monitor(callback), delay);
    };
    var clearTimeout2 = function clearTimeout2(timeoutId) {
        getZoneJsOriginalValue(getGlobalObject(), "clearTimeout")(timeoutId);
    };
    var setInterval = function setInterval(callback, delay) {
        return getZoneJsOriginalValue(window, "setInterval")(monitor(callback), delay);
    };
    var clearInterval = function clearInterval(timeoutId) {
        getZoneJsOriginalValue(window, "clearInterval")(timeoutId);
    };
    var throttle = // ../../node_modules/.pnpm/@datadog+browser-core@4.42.2/node_modules/@datadog/browser-core/esm/tools/utils/functionUtils.js
    function throttle(fn, wait, options) {
        var needLeadingExecution = options && options.leading !== void 0 ? options.leading : true;
        var needTrailingExecution = options && options.trailing !== void 0 ? options.trailing : true;
        var inWaitPeriod = false;
        var pendingExecutionWithParameters;
        var pendingTimeoutId;
        return {
            throttled: function throttled() {
                var parameters = [];
                for(var _i = 0; _i < arguments.length; _i++){
                    parameters[_i] = arguments[_i];
                }
                if (inWaitPeriod) {
                    pendingExecutionWithParameters = parameters;
                    return;
                }
                if (needLeadingExecution) {
                    fn.apply(void 0, parameters);
                } else {
                    pendingExecutionWithParameters = parameters;
                }
                inWaitPeriod = true;
                pendingTimeoutId = setTimeout2(function() {
                    if (needTrailingExecution && pendingExecutionWithParameters) {
                        fn.apply(void 0, pendingExecutionWithParameters);
                    }
                    inWaitPeriod = false;
                    pendingExecutionWithParameters = void 0;
                }, wait);
            },
            cancel: function cancel() {
                clearTimeout2(pendingTimeoutId);
                inWaitPeriod = false;
                pendingExecutionWithParameters = void 0;
            }
        };
    };
    var noop = function noop() {};
    var jsonStringify = // ../../node_modules/.pnpm/@datadog+browser-core@4.42.2/node_modules/@datadog/browser-core/esm/tools/serialisation/jsonStringify.js
    function jsonStringify(value, replacer, space) {
        if (typeof value !== "object" || value === null) {
            return JSON.stringify(value);
        }
        var restoreObjectPrototypeToJson = detachToJsonMethod(Object.prototype);
        var restoreArrayPrototypeToJson = detachToJsonMethod(Array.prototype);
        var restoreValuePrototypeToJson = detachToJsonMethod(Object.getPrototypeOf(value));
        var restoreValueToJson = detachToJsonMethod(value);
        try {
            return JSON.stringify(value, replacer, space);
        } catch (_a4) {
            return "<error: unable to serialize object>";
        } finally{
            restoreObjectPrototypeToJson();
            restoreArrayPrototypeToJson();
            restoreValuePrototypeToJson();
            restoreValueToJson();
        }
    };
    var detachToJsonMethod = function detachToJsonMethod(value) {
        var object = value;
        var objectToJson = object.toJSON;
        if (objectToJson) {
            delete object.toJSON;
            return function() {
                object.toJSON = objectToJson;
            };
        }
        return noop;
    };
    var normalizeUrl = // ../../node_modules/.pnpm/@datadog+browser-core@4.42.2/node_modules/@datadog/browser-core/esm/tools/utils/urlPolyfill.js
    function normalizeUrl(url) {
        return buildUrl(url, getLocationOrigin()).href;
    };
    var buildUrl = function buildUrl(url, base) {
        var supportedURL = getSupportedUrl();
        if (supportedURL) {
            try {
                return base !== void 0 ? new supportedURL(url, base) : new supportedURL(url);
            } catch (error) {
                throw new Error("Failed to construct URL: ".concat(String(error), " ").concat(jsonStringify({
                    url: url,
                    base: base
                })));
            }
        }
        if (base === void 0 && !/:/.test(url)) {
            throw new Error("Invalid URL: '".concat(url, "'"));
        }
        var doc = document;
        var anchorElement = doc.createElement("a");
        if (base !== void 0) {
            doc = document.implementation.createHTMLDocument("");
            var baseElement = doc.createElement("base");
            baseElement.href = base;
            doc.head.appendChild(baseElement);
            doc.body.appendChild(anchorElement);
        }
        anchorElement.href = url;
        return anchorElement;
    };
    var getSupportedUrl = function getSupportedUrl() {
        if (isURLSupported === void 0) {
            try {
                var url = new originalURL("http://test/path");
                isURLSupported = url.href === "http://test/path";
            } catch (_a4) {
                isURLSupported = false;
            }
        }
        return isURLSupported ? originalURL : void 0;
    };
    var getLocationOrigin = function getLocationOrigin() {
        return getLinkElementOrigin(window.location);
    };
    var getLinkElementOrigin = function getLinkElementOrigin(element) {
        if (element.origin) {
            return element.origin;
        }
        var sanitizedHost = element.host.replace(/(:80|:443)$/, "");
        return "".concat(element.protocol, "//").concat(sanitizedHost);
    };
    var createEndpointBuilder = function createEndpointBuilder(initConfiguration, endpointType, configurationTags) {
        var buildUrlWithParameters = createEndpointUrlWithParametersBuilder(initConfiguration, endpointType);
        return {
            build: function build(api, flushReason, retry) {
                var parameters = buildEndpointParameters(initConfiguration, endpointType, configurationTags, api, flushReason, retry);
                return buildUrlWithParameters(parameters);
            },
            urlPrefix: buildUrlWithParameters(""),
            endpointType: endpointType
        };
    };
    var createEndpointUrlWithParametersBuilder = function createEndpointUrlWithParametersBuilder(initConfiguration, endpointType) {
        var path = "/api/v2/".concat(INTAKE_TRACKS[endpointType]);
        var proxy = initConfiguration.proxy, proxyUrl = initConfiguration.proxyUrl;
        if (proxy) {
            var normalizedProxyUrl_1 = normalizeUrl(proxy);
            return function(parameters) {
                return "".concat(normalizedProxyUrl_1, "?ddforward=").concat(encodeURIComponent("".concat(path, "?").concat(parameters)));
            };
        }
        var host = buildEndpointHost(initConfiguration, endpointType);
        if (proxy === void 0 && proxyUrl) {
            var normalizedProxyUrl_2 = normalizeUrl(proxyUrl);
            return function(parameters) {
                return "".concat(normalizedProxyUrl_2, "?ddforward=").concat(encodeURIComponent("https://".concat(host).concat(path, "?").concat(parameters)));
            };
        }
        return function(parameters) {
            return "https://".concat(host).concat(path, "?").concat(parameters);
        };
    };
    var buildEndpointHost = function buildEndpointHost(initConfiguration, endpointType) {
        var _a4 = initConfiguration.site, site = _a4 === void 0 ? INTAKE_SITE_US1 : _a4, internalAnalyticsSubdomain = initConfiguration.internalAnalyticsSubdomain;
        if (internalAnalyticsSubdomain && site === INTAKE_SITE_US1) {
            return "".concat(internalAnalyticsSubdomain, ".").concat(INTAKE_SITE_US1);
        }
        var domainParts = site.split(".");
        var extension = domainParts.pop();
        var subdomain = site !== INTAKE_SITE_AP1 ? "".concat(ENDPOINTS[endpointType], ".") : "";
        return "".concat(subdomain, "browser-intake-").concat(domainParts.join("-"), ".").concat(extension);
    };
    var buildEndpointParameters = function buildEndpointParameters(_a4, endpointType, configurationTags, api, flushReason, retry) {
        var clientToken = _a4.clientToken, internalAnalyticsSubdomain = _a4.internalAnalyticsSubdomain;
        var tags = [
            "sdk_version:".concat("4.42.2"),
            "api:".concat(api)
        ].concat(configurationTags);
        if (flushReason && isExperimentalFeatureEnabled(ExperimentalFeature.COLLECT_FLUSH_REASON)) {
            tags.push("flush_reason:".concat(flushReason));
        }
        if (retry) {
            tags.push("retry_count:".concat(retry.count), "retry_after:".concat(retry.lastFailureStatus));
        }
        var parameters = [
            "ddsource=browser",
            "ddtags=".concat(encodeURIComponent(tags.join(","))),
            "dd-api-key=".concat(clientToken),
            "dd-evp-origin-version=".concat(encodeURIComponent("4.42.2")),
            "dd-evp-origin=browser",
            "dd-request-id=".concat(generateUUID())
        ];
        if (endpointType === "rum") {
            parameters.push("batch_time=".concat(timeStampNow()));
        }
        if (internalAnalyticsSubdomain) {
            parameters.reverse();
        }
        return parameters.join("&");
    };
    var buildTags = function buildTags(configuration) {
        var env = configuration.env, service = configuration.service, version = configuration.version, datacenter = configuration.datacenter;
        var tags = [];
        if (env) {
            tags.push(buildTag("env", env));
        }
        if (service) {
            tags.push(buildTag("service", service));
        }
        if (version) {
            tags.push(buildTag("version", version));
        }
        if (datacenter) {
            tags.push(buildTag("datacenter", datacenter));
        }
        return tags;
    };
    var buildTag = function buildTag(key, rawValue) {
        var valueSizeLimit = TAG_SIZE_LIMIT - key.length - 1;
        if (rawValue.length > valueSizeLimit || FORBIDDEN_CHARACTERS.test(rawValue)) {
            display.warn("".concat(key, " value doesn't meet tag requirements and will be sanitized"));
        }
        var sanitizedValue = rawValue.replace(/,/g, "_");
        return "".concat(key, ":").concat(sanitizedValue);
    };
    var computeTransportConfiguration = // ../../node_modules/.pnpm/@datadog+browser-core@4.42.2/node_modules/@datadog/browser-core/esm/domain/configuration/transportConfiguration.js
    function computeTransportConfiguration(initConfiguration) {
        var tags = buildTags(initConfiguration);
        var endpointBuilders = computeEndpointBuilders(initConfiguration, tags);
        var intakeUrlPrefixes = objectValues(endpointBuilders).map(function(builder) {
            return builder.urlPrefix;
        });
        var replicaConfiguration = computeReplicaConfiguration(initConfiguration, intakeUrlPrefixes, tags);
        return assign({
            isIntakeUrl: function isIntakeUrl(url) {
                return intakeUrlPrefixes.some(function(intakeEndpoint) {
                    return url.indexOf(intakeEndpoint) === 0;
                });
            },
            replica: replicaConfiguration,
            site: initConfiguration.site || INTAKE_SITE_US1
        }, endpointBuilders);
    };
    var computeEndpointBuilders = function computeEndpointBuilders(initConfiguration, tags) {
        return {
            logsEndpointBuilder: createEndpointBuilder(initConfiguration, "logs", tags),
            rumEndpointBuilder: createEndpointBuilder(initConfiguration, "rum", tags),
            sessionReplayEndpointBuilder: createEndpointBuilder(initConfiguration, "sessionReplay", tags)
        };
    };
    var computeReplicaConfiguration = function computeReplicaConfiguration(initConfiguration, intakeUrlPrefixes, tags) {
        if (!initConfiguration.replica) {
            return;
        }
        var replicaConfiguration = assign({}, initConfiguration, {
            site: INTAKE_SITE_US1,
            clientToken: initConfiguration.replica.clientToken
        });
        var replicaEndpointBuilders = {
            logsEndpointBuilder: createEndpointBuilder(replicaConfiguration, "logs", tags),
            rumEndpointBuilder: createEndpointBuilder(replicaConfiguration, "rum", tags)
        };
        intakeUrlPrefixes.push.apply(intakeUrlPrefixes, objectValues(replicaEndpointBuilders).map(function(builder) {
            return builder.urlPrefix;
        }));
        return assign({
            applicationId: initConfiguration.replica.applicationId
        }, replicaEndpointBuilders);
    };
    var validateAndBuildConfiguration = // ../../node_modules/.pnpm/@datadog+browser-core@4.42.2/node_modules/@datadog/browser-core/esm/domain/configuration/configuration.js
    function validateAndBuildConfiguration(initConfiguration) {
        var _a4, _b, _c;
        if (!initConfiguration || !initConfiguration.clientToken) {
            display.error("Client Token is not configured, we will not send any data.");
            return;
        }
        var sessionSampleRate = (_a4 = initConfiguration.sessionSampleRate) !== null && _a4 !== void 0 ? _a4 : initConfiguration.sampleRate;
        if (sessionSampleRate !== void 0 && !isPercentage(sessionSampleRate)) {
            display.error("Session Sample Rate should be a number between 0 and 100");
            return;
        }
        if (initConfiguration.telemetrySampleRate !== void 0 && !isPercentage(initConfiguration.telemetrySampleRate)) {
            display.error("Telemetry Sample Rate should be a number between 0 and 100");
            return;
        }
        if (initConfiguration.telemetryConfigurationSampleRate !== void 0 && !isPercentage(initConfiguration.telemetryConfigurationSampleRate)) {
            display.error("Telemetry Configuration Sample Rate should be a number between 0 and 100");
            return;
        }
        if (Array.isArray(initConfiguration.enableExperimentalFeatures)) {
            addExperimentalFeatures(initConfiguration.enableExperimentalFeatures.filter(function(flag) {
                return objectHasValue(ExperimentalFeature, flag);
            }));
        }
        return assign({
            beforeSend: initConfiguration.beforeSend && catchUserErrors(initConfiguration.beforeSend, "beforeSend threw an error:"),
            cookieOptions: buildCookieOptions(initConfiguration),
            sessionSampleRate: sessionSampleRate !== null && sessionSampleRate !== void 0 ? sessionSampleRate : 100,
            telemetrySampleRate: (_b = initConfiguration.telemetrySampleRate) !== null && _b !== void 0 ? _b : 20,
            telemetryConfigurationSampleRate: (_c = initConfiguration.telemetryConfigurationSampleRate) !== null && _c !== void 0 ? _c : 5,
            service: initConfiguration.service,
            silentMultipleInit: !!initConfiguration.silentMultipleInit,
            /**
       * beacon payload max queue size implementation is 64kb
       * ensure that we leave room for logs, rum and potential other users
       */ batchBytesLimit: 16 * ONE_KIBI_BYTE,
            eventRateLimiterThreshold: 3e3,
            maxTelemetryEventsPerPage: 15,
            /**
       * flush automatically, aim to be lower than ALB connection timeout
       * to maximize connection reuse.
       */ flushTimeout: 30 * ONE_SECOND,
            /**
       * Logs intake limit
       */ batchMessagesLimit: 50,
            messageBytesLimit: 256 * ONE_KIBI_BYTE
        }, computeTransportConfiguration(initConfiguration));
    };
    var buildCookieOptions = function buildCookieOptions(initConfiguration) {
        var cookieOptions = {};
        cookieOptions.secure = mustUseSecureCookie(initConfiguration);
        cookieOptions.crossSite = !!initConfiguration.useCrossSiteSessionCookie;
        if (initConfiguration.trackSessionAcrossSubdomains) {
            cookieOptions.domain = getCurrentSite();
        }
        return cookieOptions;
    };
    var mustUseSecureCookie = function mustUseSecureCookie(initConfiguration) {
        return !!initConfiguration.useSecureSessionCookie || !!initConfiguration.useCrossSiteSessionCookie;
    };
    var serializeConfiguration = function serializeConfiguration(configuration) {
        var _a4, _b;
        var proxy = (_a4 = configuration.proxy) !== null && _a4 !== void 0 ? _a4 : configuration.proxyUrl;
        return {
            session_sample_rate: (_b = configuration.sessionSampleRate) !== null && _b !== void 0 ? _b : configuration.sampleRate,
            telemetry_sample_rate: configuration.telemetrySampleRate,
            telemetry_configuration_sample_rate: configuration.telemetryConfigurationSampleRate,
            use_before_send: !!configuration.beforeSend,
            use_cross_site_session_cookie: configuration.useCrossSiteSessionCookie,
            use_secure_session_cookie: configuration.useSecureSessionCookie,
            use_proxy: proxy !== void 0 ? !!proxy : void 0,
            silent_multiple_init: configuration.silentMultipleInit,
            track_session_across_subdomains: configuration.trackSessionAcrossSubdomains,
            track_resources: configuration.trackResources,
            track_long_task: configuration.trackLongTasks
        };
    };
    var computeStackTrace = function computeStackTrace(ex) {
        var stack = [];
        var stackProperty = tryToGetString(ex, "stack");
        var exString = String(ex);
        if (stackProperty && startsWith(stackProperty, exString)) {
            stackProperty = stackProperty.slice(exString.length);
        }
        if (stackProperty) {
            stackProperty.split("\n").forEach(function(line) {
                var stackFrame = parseChromeLine(line) || parseChromeAnonymousLine(line) || parseWinLine(line) || parseGeckoLine(line);
                if (stackFrame) {
                    if (!stackFrame.func && stackFrame.line) {
                        stackFrame.func = UNKNOWN_FUNCTION;
                    }
                    stack.push(stackFrame);
                }
            });
        }
        return {
            message: tryToGetString(ex, "message"),
            name: tryToGetString(ex, "name"),
            stack: stack
        };
    };
    var parseChromeLine = function parseChromeLine(line) {
        var parts = CHROME_LINE_RE.exec(line);
        if (!parts) {
            return;
        }
        var isNative = parts[2] && parts[2].indexOf("native") === 0;
        var isEval = parts[2] && parts[2].indexOf("eval") === 0;
        var submatch = CHROME_EVAL_RE.exec(parts[2]);
        if (isEval && submatch) {
            parts[2] = submatch[1];
            parts[3] = submatch[2];
            parts[4] = submatch[3];
        }
        return {
            args: isNative ? [
                parts[2]
            ] : [],
            column: parts[4] ? +parts[4] : void 0,
            func: parts[1] || UNKNOWN_FUNCTION,
            line: parts[3] ? +parts[3] : void 0,
            url: !isNative ? parts[2] : void 0
        };
    };
    var parseChromeAnonymousLine = function parseChromeAnonymousLine(line) {
        var parts = CHROME_ANONYMOUS_FUNCTION_RE.exec(line);
        if (!parts) {
            return;
        }
        return {
            args: [],
            column: parts[3] ? +parts[3] : void 0,
            func: UNKNOWN_FUNCTION,
            line: parts[2] ? +parts[2] : void 0,
            url: parts[1]
        };
    };
    var parseWinLine = function parseWinLine(line) {
        var parts = WINJS_LINE_RE.exec(line);
        if (!parts) {
            return;
        }
        return {
            args: [],
            column: parts[4] ? +parts[4] : void 0,
            func: parts[1] || UNKNOWN_FUNCTION,
            line: +parts[3],
            url: parts[2]
        };
    };
    var parseGeckoLine = function parseGeckoLine(line) {
        var parts = GECKO_LINE_RE.exec(line);
        if (!parts) {
            return;
        }
        var isEval = parts[3] && parts[3].indexOf(" > eval") > -1;
        var submatch = GECKO_EVAL_RE.exec(parts[3]);
        if (isEval && submatch) {
            parts[3] = submatch[1];
            parts[4] = submatch[2];
            parts[5] = void 0;
        }
        return {
            args: parts[2] ? parts[2].split(",") : [],
            column: parts[5] ? +parts[5] : void 0,
            func: parts[1] || UNKNOWN_FUNCTION,
            line: parts[4] ? +parts[4] : void 0,
            url: parts[3]
        };
    };
    var tryToGetString = function tryToGetString(candidate, property) {
        if (typeof candidate !== "object" || !candidate || !(property in candidate)) {
            return void 0;
        }
        var value = candidate[property];
        return typeof value === "string" ? value : void 0;
    };
    var instrumentMethod = // ../../node_modules/.pnpm/@datadog+browser-core@4.42.2/node_modules/@datadog/browser-core/esm/tools/instrumentMethod.js
    function instrumentMethod(object, method, instrumentationFactory) {
        var original = object[method];
        var instrumentation = instrumentationFactory(original);
        var instrumentationWrapper = function instrumentationWrapper() {
            if (typeof instrumentation !== "function") {
                return void 0;
            }
            return instrumentation.apply(this, arguments);
        };
        object[method] = instrumentationWrapper;
        return {
            stop: function stop() {
                if (object[method] === instrumentationWrapper) {
                    object[method] = original;
                } else {
                    instrumentation = original;
                }
            }
        };
    };
    var instrumentMethodAndCallOriginal = function instrumentMethodAndCallOriginal(object, method, _a4) {
        var before = _a4.before, after = _a4.after;
        return instrumentMethod(object, method, function(original) {
            return function() {
                var args = arguments;
                var result;
                if (before) {
                    callMonitored(before, this, args);
                }
                if (typeof original === "function") {
                    result = original.apply(this, args);
                }
                if (after) {
                    callMonitored(after, this, args);
                }
                return result;
            };
        });
    };
    var startUnhandledErrorCollection = function startUnhandledErrorCollection(callback) {
        var stopInstrumentingOnError = instrumentOnError(callback).stop;
        var stopInstrumentingOnUnhandledRejection = instrumentUnhandledRejection(callback).stop;
        return {
            stop: function stop() {
                stopInstrumentingOnError();
                stopInstrumentingOnUnhandledRejection();
            }
        };
    };
    var instrumentOnError = function instrumentOnError(callback) {
        return instrumentMethodAndCallOriginal(window, "onerror", {
            before: function before(messageObj, url, line, column, errorObj) {
                var stackTrace;
                if (_instanceof(errorObj, Error)) {
                    stackTrace = computeStackTrace(errorObj);
                } else {
                    var stack = [
                        {
                            url: url,
                            column: column,
                            line: line
                        }
                    ];
                    var _a4 = tryToParseMessage(messageObj), name_1 = _a4.name, message = _a4.message;
                    stackTrace = {
                        name: name_1,
                        message: message,
                        stack: stack
                    };
                }
                callback(stackTrace, errorObj !== null && errorObj !== void 0 ? errorObj : messageObj);
            }
        });
    };
    var tryToParseMessage = function tryToParseMessage(messageObj) {
        var _a4;
        var name;
        var message;
        if (({}).toString.call(messageObj) === "[object String]") {
            ;
            _a4 = ERROR_TYPES_RE.exec(messageObj), name = _a4[1], message = _a4[2];
        }
        return {
            name: name,
            message: message
        };
    };
    var instrumentUnhandledRejection = function instrumentUnhandledRejection(callback) {
        return instrumentMethodAndCallOriginal(window, "onunhandledrejection", {
            before: function before(e2) {
                var reason = e2.reason || "Empty reason";
                var stack = computeStackTrace(reason);
                callback(stack, reason);
            }
        });
    };
    var sanitize = function sanitize(source, maxCharacterCount) {
        var _a4;
        if (maxCharacterCount === void 0) {
            maxCharacterCount = SANITIZE_DEFAULT_MAX_CHARACTER_COUNT;
        }
        var restoreObjectPrototypeToJson = detachToJsonMethod(Object.prototype);
        var restoreArrayPrototypeToJson = detachToJsonMethod(Array.prototype);
        var containerQueue = [];
        var visitedObjectsWithPath = /* @__PURE__ */ new WeakMap();
        var sanitizedData = sanitizeProcessor(source, JSON_PATH_ROOT_ELEMENT, void 0, containerQueue, visitedObjectsWithPath);
        var accumulatedCharacterCount = ((_a4 = JSON.stringify(sanitizedData)) === null || _a4 === void 0 ? void 0 : _a4.length) || 0;
        if (accumulatedCharacterCount > maxCharacterCount) {
            warnOverCharacterLimit(maxCharacterCount, "discarded", source);
            return void 0;
        }
        while(containerQueue.length > 0 && accumulatedCharacterCount < maxCharacterCount){
            var containerToProcess = containerQueue.shift();
            var separatorLength = 0;
            if (Array.isArray(containerToProcess.source)) {
                for(var key = 0; key < containerToProcess.source.length; key++){
                    var targetData = sanitizeProcessor(containerToProcess.source[key], containerToProcess.path, key, containerQueue, visitedObjectsWithPath);
                    if (targetData !== void 0) {
                        accumulatedCharacterCount += JSON.stringify(targetData).length;
                    } else {
                        accumulatedCharacterCount += 4;
                    }
                    accumulatedCharacterCount += separatorLength;
                    separatorLength = 1;
                    if (accumulatedCharacterCount > maxCharacterCount) {
                        warnOverCharacterLimit(maxCharacterCount, "truncated", source);
                        break;
                    }
                    ;
                    containerToProcess.target[key] = targetData;
                }
            } else {
                for(var key in containerToProcess.source){
                    if (Object.prototype.hasOwnProperty.call(containerToProcess.source, key)) {
                        var targetData = sanitizeProcessor(containerToProcess.source[key], containerToProcess.path, key, containerQueue, visitedObjectsWithPath);
                        if (targetData !== void 0) {
                            accumulatedCharacterCount += JSON.stringify(targetData).length + separatorLength + key.length + KEY_DECORATION_LENGTH;
                            separatorLength = 1;
                        }
                        if (accumulatedCharacterCount > maxCharacterCount) {
                            warnOverCharacterLimit(maxCharacterCount, "truncated", source);
                            break;
                        }
                        ;
                        containerToProcess.target[key] = targetData;
                    }
                }
            }
        }
        restoreObjectPrototypeToJson();
        restoreArrayPrototypeToJson();
        return sanitizedData;
    };
    var sanitizeProcessor = function sanitizeProcessor(source, parentPath, key, queue, visitedObjectsWithPath) {
        var sourceToSanitize = tryToApplyToJSON(source);
        if (!sourceToSanitize || typeof sourceToSanitize !== "object") {
            return sanitizePrimitivesAndFunctions(sourceToSanitize);
        }
        var sanitizedSource = sanitizeObjects(sourceToSanitize);
        if (sanitizedSource !== "[Object]" && sanitizedSource !== "[Array]" && sanitizedSource !== "[Error]") {
            return sanitizedSource;
        }
        var sourceAsObject = source;
        if (visitedObjectsWithPath.has(sourceAsObject)) {
            return "[Reference seen at ".concat(visitedObjectsWithPath.get(sourceAsObject), "]");
        }
        var currentPath = key !== void 0 ? "".concat(parentPath, ".").concat(key) : parentPath;
        var target = Array.isArray(sourceToSanitize) ? [] : {};
        visitedObjectsWithPath.set(sourceAsObject, currentPath);
        queue.push({
            source: sourceToSanitize,
            target: target,
            path: currentPath
        });
        return target;
    };
    var sanitizePrimitivesAndFunctions = function sanitizePrimitivesAndFunctions(value) {
        if ((typeof value === "undefined" ? "undefined" : _type_of(value)) === "bigint") {
            return "[BigInt] ".concat(value.toString());
        }
        if (typeof value === "function") {
            return "[Function] ".concat(value.name || "unknown");
        }
        if ((typeof value === "undefined" ? "undefined" : _type_of(value)) === "symbol") {
            return "[Symbol] ".concat(value.description || value.toString());
        }
        return value;
    };
    var sanitizeObjects = function sanitizeObjects(value) {
        try {
            if (_instanceof(value, Event)) {
                return {
                    isTrusted: value.isTrusted
                };
            }
            var result = Object.prototype.toString.call(value);
            var match = result.match(/\[object (.*)\]/);
            if (match && match[1]) {
                return "[".concat(match[1], "]");
            }
        } catch (_a4) {}
        return "[Unserializable]";
    };
    var tryToApplyToJSON = function tryToApplyToJSON(value) {
        var object = value;
        if (object && typeof object.toJSON === "function") {
            try {
                return object.toJSON();
            } catch (_a4) {}
        }
        return value;
    };
    var warnOverCharacterLimit = function warnOverCharacterLimit(maxCharacterCount, changeType, source) {
        display.warn("The data provided has been ".concat(changeType, " as it is over the limit of ").concat(maxCharacterCount, " characters:"), source);
    };
    var computeRawError = function computeRawError(_a4) {
        var stackTrace = _a4.stackTrace, originalError = _a4.originalError, handlingStack = _a4.handlingStack, startClocks = _a4.startClocks, nonErrorPrefix = _a4.nonErrorPrefix, source = _a4.source, handling = _a4.handling;
        var isErrorInstance = _instanceof(originalError, Error);
        var message = computeMessage(stackTrace, isErrorInstance, nonErrorPrefix, originalError);
        var stack = hasUsableStack(isErrorInstance, stackTrace) ? toStackTraceString(stackTrace) : NO_ERROR_STACK_PRESENT_MESSAGE;
        var causes = isErrorInstance ? flattenErrorCauses(originalError, source) : void 0;
        var type = stackTrace === null || stackTrace === void 0 ? void 0 : stackTrace.name;
        var fingerprint = tryToGetFingerprint(originalError);
        return {
            startClocks: startClocks,
            source: source,
            handling: handling,
            handlingStack: handlingStack,
            originalError: originalError,
            type: type,
            message: message,
            stack: stack,
            causes: causes,
            fingerprint: fingerprint
        };
    };
    var computeMessage = function computeMessage(stackTrace, isErrorInstance, nonErrorPrefix, originalError) {
        return (stackTrace === null || stackTrace === void 0 ? void 0 : stackTrace.message) && (stackTrace === null || stackTrace === void 0 ? void 0 : stackTrace.name) ? stackTrace.message : !isErrorInstance ? "".concat(nonErrorPrefix, " ").concat(jsonStringify(sanitize(originalError))) : "Empty message";
    };
    var hasUsableStack = function hasUsableStack(isErrorInstance, stackTrace) {
        if (stackTrace === void 0) {
            return false;
        }
        if (isErrorInstance) {
            return true;
        }
        return stackTrace.stack.length > 0 && (stackTrace.stack.length > 1 || stackTrace.stack[0].url !== void 0);
    };
    var tryToGetFingerprint = function tryToGetFingerprint(originalError) {
        return _instanceof(originalError, Error) && "dd_fingerprint" in originalError ? String(originalError.dd_fingerprint) : void 0;
    };
    var toStackTraceString = function toStackTraceString(stack) {
        var result = formatErrorMessage(stack);
        stack.stack.forEach(function(frame) {
            var func = frame.func === "?" ? "<anonymous>" : frame.func;
            var args = frame.args && frame.args.length > 0 ? "(".concat(frame.args.join(", "), ")") : "";
            var line = frame.line ? ":".concat(frame.line) : "";
            var column = frame.line && frame.column ? ":".concat(frame.column) : "";
            result += "\n  at ".concat(func).concat(args, " @ ").concat(frame.url).concat(line).concat(column);
        });
        return result;
    };
    var getFileFromStackTraceString = function getFileFromStackTraceString(stack) {
        var _a4;
        return (_a4 = /@ (.+)/.exec(stack)) === null || _a4 === void 0 ? void 0 : _a4[1];
    };
    var formatErrorMessage = function formatErrorMessage(stack) {
        return "".concat(stack.name || "Error", ": ").concat(stack.message);
    };
    var createHandlingStack = function createHandlingStack() {
        var internalFramesToSkip = 2;
        var error = new Error();
        var formattedStack;
        if (!error.stack) {
            try {
                throw error;
            } catch (e2) {
                noop();
            }
        }
        callMonitored(function() {
            var stackTrace = computeStackTrace(error);
            stackTrace.stack = stackTrace.stack.slice(internalFramesToSkip);
            formattedStack = toStackTraceString(stackTrace);
        });
        return formattedStack;
    };
    var flattenErrorCauses = function flattenErrorCauses(error, parentSource) {
        var currentError = error;
        var causes = [];
        while(_instanceof(currentError === null || currentError === void 0 ? void 0 : currentError.cause, Error) && causes.length < 10){
            var stackTrace = computeStackTrace(currentError.cause);
            causes.push({
                message: currentError.cause.message,
                source: parentSource,
                type: stackTrace === null || stackTrace === void 0 ? void 0 : stackTrace.name,
                stack: stackTrace && toStackTraceString(stackTrace)
            });
            currentError = currentError.cause;
        }
        return causes.length ? causes : void 0;
    };
    var trackRuntimeError = // ../../node_modules/.pnpm/@datadog+browser-core@4.42.2/node_modules/@datadog/browser-core/esm/domain/error/trackRuntimeError.js
    function trackRuntimeError(errorObservable) {
        return startUnhandledErrorCollection(function(stackTrace, originalError) {
            errorObservable.notify(computeRawError({
                stackTrace: stackTrace,
                originalError: originalError,
                startClocks: clocksNow(),
                nonErrorPrefix: "Uncaught",
                source: ErrorSource.SOURCE,
                handling: "unhandled"
            }));
        });
    };
    var makePublicApi = // ../../node_modules/.pnpm/@datadog+browser-core@4.42.2/node_modules/@datadog/browser-core/esm/boot/init.js
    function makePublicApi(stub) {
        var publicApi = assign({
            version: "4.42.2",
            // This API method is intentionally not monitored, since the only thing executed is the
            // user-provided 'callback'.  All SDK usages executed in the callback should be monitored, and
            // we don't want to interfere with the user uncaught exceptions.
            onReady: function onReady(callback) {
                callback();
            }
        }, stub);
        Object.defineProperty(publicApi, "_setDebug", {
            get: function get() {
                return setDebugMode;
            },
            enumerable: false
        });
        return publicApi;
    };
    var defineGlobal = function defineGlobal(global2, name, api) {
        var existingGlobalVariable = global2[name];
        global2[name] = api;
        if (existingGlobalVariable && existingGlobalVariable.q) {
            existingGlobalVariable.q.forEach(function(fn) {
                return catchUserErrors(fn, "onReady callback threw an error:")();
            });
        }
    };
    var mergeObservables = function mergeObservables() {
        var observables = [];
        for(var _i = 0; _i < arguments.length; _i++){
            observables[_i] = arguments[_i];
        }
        var globalObservable = new Observable(function() {
            var subscriptions = observables.map(function(observable) {
                return observable.subscribe(function(data) {
                    return globalObservable.notify(data);
                });
            });
            return function() {
                return subscriptions.forEach(function(subscription) {
                    return subscription.unsubscribe();
                });
            };
        });
        return globalObservable;
    };
    var addEventListener = // ../../node_modules/.pnpm/@datadog+browser-core@4.42.2/node_modules/@datadog/browser-core/esm/browser/addEventListener.js
    function addEventListener(eventTarget, eventName, listener, options) {
        return addEventListeners(eventTarget, [
            eventName
        ], listener, options);
    };
    var addEventListeners = function addEventListeners(eventTarget, eventNames, listener, _a4) {
        var _b = _a4 === void 0 ? {} : _a4, once = _b.once, capture = _b.capture, passive = _b.passive;
        var wrappedListener = monitor(once ? function(event) {
            stop();
            listener(event);
        } : listener);
        var options = passive ? {
            capture: capture,
            passive: passive
        } : capture;
        var add = getZoneJsOriginalValue(eventTarget, "addEventListener");
        eventNames.forEach(function(eventName) {
            return add.call(eventTarget, eventName, wrappedListener, options);
        });
        function stop() {
            var remove = getZoneJsOriginalValue(eventTarget, "removeEventListener");
            eventNames.forEach(function(eventName) {
                return remove.call(eventTarget, eventName, wrappedListener, options);
            });
        }
        return {
            stop: stop
        };
    };
    var initReportObservable = function initReportObservable(apis) {
        var observables = [];
        if (includes(apis, RawReportType.cspViolation)) {
            observables.push(createCspViolationReportObservable());
        }
        var reportTypes = apis.filter(function(api) {
            return api !== RawReportType.cspViolation;
        });
        if (reportTypes.length) {
            observables.push(createReportObservable(reportTypes));
        }
        return mergeObservables.apply(void 0, observables);
    };
    var createReportObservable = function createReportObservable(reportTypes) {
        var observable = new Observable(function() {
            if (!window.ReportingObserver) {
                return;
            }
            var handleReports = monitor(function(reports) {
                return reports.forEach(function(report) {
                    observable.notify(buildRawReportFromReport(report));
                });
            });
            var observer = new window.ReportingObserver(handleReports, {
                types: reportTypes,
                buffered: true
            });
            observer.observe();
            return function() {
                observer.disconnect();
            };
        });
        return observable;
    };
    var createCspViolationReportObservable = function createCspViolationReportObservable() {
        var observable = new Observable(function() {
            var stop = addEventListener(document, "securitypolicyviolation", function(event) {
                observable.notify(buildRawReportFromCspViolation(event));
            }).stop;
            return stop;
        });
        return observable;
    };
    var buildRawReportFromReport = function buildRawReportFromReport(_a4) {
        var type = _a4.type, body = _a4.body;
        return {
            type: type,
            subtype: body.id,
            message: "".concat(type, ": ").concat(body.message),
            stack: buildStack(body.id, body.message, body.sourceFile, body.lineNumber, body.columnNumber)
        };
    };
    var buildRawReportFromCspViolation = function buildRawReportFromCspViolation(event) {
        var type = RawReportType.cspViolation;
        var message = "'".concat(event.blockedURI, "' blocked by '").concat(event.effectiveDirective, "' directive");
        return {
            type: RawReportType.cspViolation,
            subtype: event.effectiveDirective,
            message: "".concat(type, ": ").concat(message),
            stack: buildStack(event.effectiveDirective, event.originalPolicy ? "".concat(message, ' of the policy "').concat(safeTruncate(event.originalPolicy, 100, "..."), '"') : "no policy", event.sourceFile, event.lineNumber, event.columnNumber)
        };
    };
    var buildStack = function buildStack(name, message, sourceFile, lineNumber, columnNumber) {
        return sourceFile && toStackTraceString({
            name: name,
            message: message,
            stack: [
                {
                    func: "?",
                    url: sourceFile,
                    line: lineNumber,
                    column: columnNumber
                }
            ]
        });
    };
    var sendToExtension = // ../../node_modules/.pnpm/@datadog+browser-core@4.42.2/node_modules/@datadog/browser-core/esm/tools/sendToExtension.js
    function sendToExtension(type, payload) {
        var callback = window.__ddBrowserSdkExtensionCallback;
        if (callback) {
            callback({
                type: type,
                payload: payload
            });
        }
    };
    var getType = // ../../node_modules/.pnpm/@datadog+browser-core@4.42.2/node_modules/@datadog/browser-core/esm/tools/utils/typeUtils.js
    function getType(value) {
        if (value === null) {
            return "null";
        }
        if (Array.isArray(value)) {
            return "array";
        }
        return typeof value === "undefined" ? "undefined" : _type_of(value);
    };
    var deepClone = function deepClone(value) {
        return mergeInto(void 0, value);
    };
    var combine = function combine() {
        var sources = [];
        for(var _i = 0; _i < arguments.length; _i++){
            sources[_i] = arguments[_i];
        }
        var destination;
        for(var _a4 = 0, sources_1 = sources; _a4 < sources_1.length; _a4++){
            var source = sources_1[_a4];
            if (source === void 0 || source === null) {
                continue;
            }
            destination = mergeInto(destination, source);
        }
        return destination;
    };
    var createCircularReferenceChecker = function createCircularReferenceChecker() {
        if (typeof WeakSet !== "undefined") {
            var set_1 = /* @__PURE__ */ new WeakSet();
            return {
                hasAlreadyBeenSeen: function hasAlreadyBeenSeen(value) {
                    var has = set_1.has(value);
                    if (!has) {
                        set_1.add(value);
                    }
                    return has;
                }
            };
        }
        var array = [];
        return {
            hasAlreadyBeenSeen: function hasAlreadyBeenSeen(value) {
                var has = array.indexOf(value) >= 0;
                if (!has) {
                    array.push(value);
                }
                return has;
            }
        };
    };
    var startTelemetry = function startTelemetry(telemetryService, configuration) {
        var contextProvider;
        var observable = new Observable();
        telemetryConfiguration.telemetryEnabled = !includes(TELEMETRY_EXCLUDED_SITES, configuration.site) && performDraw(configuration.telemetrySampleRate);
        telemetryConfiguration.telemetryConfigurationEnabled = telemetryConfiguration.telemetryEnabled && performDraw(configuration.telemetryConfigurationSampleRate);
        onRawTelemetryEventCollected = function onRawTelemetryEventCollected(rawEvent) {
            if (telemetryConfiguration.telemetryEnabled) {
                var event_1 = toTelemetryEvent(telemetryService, rawEvent);
                observable.notify(event_1);
                sendToExtension("telemetry", event_1);
            }
        };
        startMonitorErrorCollection(addTelemetryError);
        assign(telemetryConfiguration, {
            maxEventsPerPage: configuration.maxTelemetryEventsPerPage,
            sentEventCount: 0
        });
        function toTelemetryEvent(telemetryService2, event) {
            return combine({
                type: "telemetry",
                date: timeStampNow(),
                service: telemetryService2,
                version: "4.42.2",
                source: "browser",
                _dd: {
                    format_version: 2
                },
                telemetry: event,
                experimental_features: arrayFrom(getExperimentalFeatures())
            }, contextProvider !== void 0 ? contextProvider() : {});
        }
        return {
            setContextProvider: function setContextProvider(provider) {
                contextProvider = provider;
            },
            observable: observable,
            enabled: telemetryConfiguration.telemetryEnabled
        };
    };
    var isTelemetryReplicationAllowed = function isTelemetryReplicationAllowed(configuration) {
        return configuration.site === INTAKE_SITE_STAGING;
    };
    var addTelemetryDebug = function addTelemetryDebug(message, context) {
        displayIfDebugEnabled(ConsoleApiName.debug, message, context);
        addTelemetry(assign({
            type: TelemetryType.log,
            message: message,
            status: "debug"
        }, context));
    };
    var addTelemetryError = function addTelemetryError(e2) {
        addTelemetry(assign({
            type: TelemetryType.log,
            status: "error"
        }, formatError(e2)));
    };
    var addTelemetryConfiguration = function addTelemetryConfiguration(configuration) {
        if (telemetryConfiguration.telemetryConfigurationEnabled) {
            addTelemetry({
                type: TelemetryType.configuration,
                configuration: configuration
            });
        }
    };
    var addTelemetry = function addTelemetry(event) {
        if (onRawTelemetryEventCollected && telemetryConfiguration.sentEventCount < telemetryConfiguration.maxEventsPerPage) {
            telemetryConfiguration.sentEventCount += 1;
            onRawTelemetryEventCollected(event);
        }
    };
    var formatError = function formatError(e2) {
        if (_instanceof(e2, Error)) {
            var stackTrace = computeStackTrace(e2);
            return {
                error: {
                    kind: stackTrace.name,
                    stack: toStackTraceString(scrubCustomerFrames(stackTrace))
                },
                message: stackTrace.message
            };
        }
        return {
            error: {
                stack: NO_ERROR_STACK_PRESENT_MESSAGE
            },
            message: "".concat("Uncaught", " ").concat(jsonStringify(e2))
        };
    };
    var scrubCustomerFrames = function scrubCustomerFrames(stackTrace) {
        stackTrace.stack = stackTrace.stack.filter(function(frame) {
            return !frame.url || ALLOWED_FRAME_URLS.some(function(allowedFrameUrl) {
                return startsWith(frame.url, allowedFrameUrl);
            });
        });
        return stackTrace;
    };
    var isChromium = // ../../node_modules/.pnpm/@datadog+browser-core@4.42.2/node_modules/@datadog/browser-core/esm/tools/utils/browserDetection.js
    function isChromium() {
        return !!window.chrome || /HeadlessChrome/.test(window.navigator.userAgent);
    };
    var withCookieLockAccess = function withCookieLockAccess(operations, numberOfRetries) {
        var _a4;
        if (numberOfRetries === void 0) {
            numberOfRetries = 0;
        }
        if (!ongoingOperations) {
            ongoingOperations = operations;
        }
        if (operations !== ongoingOperations) {
            bufferedOperations.push(operations);
            return;
        }
        if (numberOfRetries >= MAX_NUMBER_OF_LOCK_RETRIES) {
            next();
            return;
        }
        var currentLock;
        var currentSession = retrieveSessionCookie();
        if (isCookieLockEnabled()) {
            if (currentSession.lock) {
                retryLater(operations, numberOfRetries);
                return;
            }
            currentLock = generateUUID();
            currentSession.lock = currentLock;
            setSessionCookie(currentSession, operations.options);
            currentSession = retrieveSessionCookie();
            if (currentSession.lock !== currentLock) {
                retryLater(operations, numberOfRetries);
                return;
            }
        }
        var processedSession = operations.process(currentSession);
        if (isCookieLockEnabled()) {
            currentSession = retrieveSessionCookie();
            if (currentSession.lock !== currentLock) {
                retryLater(operations, numberOfRetries);
                return;
            }
        }
        if (processedSession) {
            persistSessionCookie(processedSession, operations.options);
        }
        if (isCookieLockEnabled()) {
            if (!(processedSession && isExpiredState(processedSession))) {
                currentSession = retrieveSessionCookie();
                if (currentSession.lock !== currentLock) {
                    retryLater(operations, numberOfRetries);
                    return;
                }
                delete currentSession.lock;
                setSessionCookie(currentSession, operations.options);
                processedSession = currentSession;
            }
        }
        (_a4 = operations.after) === null || _a4 === void 0 ? void 0 : _a4.call(operations, processedSession || currentSession);
        next();
    };
    var isCookieLockEnabled = function isCookieLockEnabled() {
        return isChromium();
    };
    var retryLater = function retryLater(operations, currentNumberOfRetries) {
        setTimeout2(function() {
            withCookieLockAccess(operations, currentNumberOfRetries + 1);
        }, LOCK_RETRY_DELAY);
    };
    var next = function next() {
        ongoingOperations = void 0;
        var nextOperations = bufferedOperations.shift();
        if (nextOperations) {
            withCookieLockAccess(nextOperations);
        }
    };
    var persistSessionCookie = function persistSessionCookie(session, options) {
        if (isExpiredState(session)) {
            deleteSessionCookie(options);
            return;
        }
        session.expire = String(dateNow() + SESSION_EXPIRATION_DELAY);
        setSessionCookie(session, options);
    };
    var setSessionCookie = function setSessionCookie(session, options) {
        setCookie(SESSION_COOKIE_NAME, toSessionString(session), SESSION_EXPIRATION_DELAY, options);
    };
    var toSessionString = function toSessionString(session) {
        return objectEntries(session).map(function(_a4) {
            var key = _a4[0], value = _a4[1];
            return "".concat(key, "=").concat(value);
        }).join(SESSION_ENTRY_SEPARATOR);
    };
    var retrieveSessionCookie = function retrieveSessionCookie() {
        var sessionString = getCookie(SESSION_COOKIE_NAME);
        var session = {};
        if (isValidSessionString(sessionString)) {
            sessionString.split(SESSION_ENTRY_SEPARATOR).forEach(function(entry) {
                var matches = SESSION_ENTRY_REGEXP.exec(entry);
                if (matches !== null) {
                    var key = matches[1], value = matches[2];
                    session[key] = value;
                }
            });
        }
        return session;
    };
    var deleteSessionCookie = function deleteSessionCookie(options) {
        deleteCookie(SESSION_COOKIE_NAME, options);
    };
    var isValidSessionString = function isValidSessionString(sessionString) {
        return sessionString !== void 0 && (sessionString.indexOf(SESSION_ENTRY_SEPARATOR) !== -1 || SESSION_ENTRY_REGEXP.test(sessionString));
    };
    var isExpiredState = function isExpiredState(session) {
        return isEmptyObject(session);
    };
    var tryOldCookiesMigration = function tryOldCookiesMigration(options) {
        var sessionString = getCookie(SESSION_COOKIE_NAME);
        var oldSessionId = getCookie(OLD_SESSION_COOKIE_NAME);
        var oldRumType = getCookie(OLD_RUM_COOKIE_NAME);
        var oldLogsType = getCookie(OLD_LOGS_COOKIE_NAME);
        if (!sessionString) {
            var session = {};
            if (oldSessionId) {
                session.id = oldSessionId;
            }
            if (oldLogsType && /^[01]$/.test(oldLogsType)) {
                session[LOGS_SESSION_KEY] = oldLogsType;
            }
            if (oldRumType && /^[012]$/.test(oldRumType)) {
                session[RUM_SESSION_KEY] = oldRumType;
            }
            persistSessionCookie(session, options);
        }
    };
    var startSessionStore = // ../../node_modules/.pnpm/@datadog+browser-core@4.42.2/node_modules/@datadog/browser-core/esm/domain/session/sessionStore.js
    function startSessionStore(options, productKey, computeSessionState2) {
        var renewObservable = new Observable();
        var expireObservable = new Observable();
        var watchSessionTimeoutId = setInterval(watchSession, COOKIE_ACCESS_DELAY);
        var sessionCache = retrieveActiveSession();
        function expandOrRenewSession() {
            var isTracked;
            withCookieLockAccess({
                options: options,
                process: function process(cookieSession) {
                    var synchronizedSession = synchronizeSession(cookieSession);
                    isTracked = expandOrRenewCookie(synchronizedSession);
                    return synchronizedSession;
                },
                after: function after(cookieSession) {
                    if (isTracked && !hasSessionInCache()) {
                        renewSessionInCache(cookieSession);
                    }
                    sessionCache = cookieSession;
                }
            });
        }
        function expandSession() {
            withCookieLockAccess({
                options: options,
                process: function process(cookieSession) {
                    return hasSessionInCache() ? synchronizeSession(cookieSession) : void 0;
                }
            });
        }
        function watchSession() {
            withCookieLockAccess({
                options: options,
                process: function process(cookieSession) {
                    return !isActiveSession(cookieSession) ? {} : void 0;
                },
                after: synchronizeSession
            });
        }
        function synchronizeSession(cookieSession) {
            if (!isActiveSession(cookieSession)) {
                cookieSession = {};
            }
            if (hasSessionInCache()) {
                if (isSessionInCacheOutdated(cookieSession)) {
                    expireSessionInCache();
                } else {
                    sessionCache = cookieSession;
                }
            }
            return cookieSession;
        }
        function expandOrRenewCookie(cookieSession) {
            var _a4 = computeSessionState2(cookieSession[productKey]), trackingType = _a4.trackingType, isTracked = _a4.isTracked;
            cookieSession[productKey] = trackingType;
            if (isTracked && !cookieSession.id) {
                cookieSession.id = generateUUID();
                cookieSession.created = String(dateNow());
            }
            return isTracked;
        }
        function hasSessionInCache() {
            return sessionCache[productKey] !== void 0;
        }
        function isSessionInCacheOutdated(cookieSession) {
            return sessionCache.id !== cookieSession.id || sessionCache[productKey] !== cookieSession[productKey];
        }
        function expireSessionInCache() {
            sessionCache = {};
            expireObservable.notify();
        }
        function renewSessionInCache(cookieSession) {
            sessionCache = cookieSession;
            renewObservable.notify();
        }
        function retrieveActiveSession() {
            var session = retrieveSessionCookie();
            if (isActiveSession(session)) {
                return session;
            }
            return {};
        }
        function isActiveSession(session) {
            return (session.created === void 0 || dateNow() - Number(session.created) < SESSION_TIME_OUT_DELAY) && (session.expire === void 0 || dateNow() < Number(session.expire));
        }
        return {
            expandOrRenewSession: throttle(expandOrRenewSession, COOKIE_ACCESS_DELAY).throttled,
            expandSession: expandSession,
            getSession: function getSession() {
                return sessionCache;
            },
            renewObservable: renewObservable,
            expireObservable: expireObservable,
            expire: function expire() {
                deleteSessionCookie(options);
                synchronizeSession({});
            },
            stop: function stop() {
                clearInterval(watchSessionTimeoutId);
            }
        };
    };
    var startSessionManager = function startSessionManager(options, productKey, computeSessionState2) {
        tryOldCookiesMigration(options);
        var sessionStore = startSessionStore(options, productKey, computeSessionState2);
        stopCallbacks.push(function() {
            return sessionStore.stop();
        });
        var sessionContextHistory = new ValueHistory(SESSION_CONTEXT_TIMEOUT_DELAY);
        stopCallbacks.push(function() {
            return sessionContextHistory.stop();
        });
        sessionStore.renewObservable.subscribe(function() {
            sessionContextHistory.add(buildSessionContext(), relativeNow());
        });
        sessionStore.expireObservable.subscribe(function() {
            sessionContextHistory.closeActive(relativeNow());
        });
        sessionStore.expandOrRenewSession();
        sessionContextHistory.add(buildSessionContext(), clocksOrigin().relative);
        trackActivity(function() {
            return sessionStore.expandOrRenewSession();
        });
        trackVisibility(function() {
            return sessionStore.expandSession();
        });
        function buildSessionContext() {
            return {
                id: sessionStore.getSession().id,
                trackingType: sessionStore.getSession()[productKey]
            };
        }
        return {
            findActiveSession: function findActiveSession(startTime) {
                return sessionContextHistory.find(startTime);
            },
            renewObservable: sessionStore.renewObservable,
            expireObservable: sessionStore.expireObservable,
            expire: sessionStore.expire
        };
    };
    var trackActivity = function trackActivity(expandOrRenewSession) {
        var stop = addEventListeners(window, [
            "click",
            "touchstart",
            "keydown",
            "scroll"
        ], expandOrRenewSession, {
            capture: true,
            passive: true
        }).stop;
        stopCallbacks.push(stop);
    };
    var trackVisibility = function trackVisibility(expandSession) {
        var expandSessionWhenVisible = function expandSessionWhenVisible() {
            if (document.visibilityState === "visible") {
                expandSession();
            }
        };
        var stop = addEventListener(document, "visibilitychange", expandSessionWhenVisible).stop;
        stopCallbacks.push(stop);
        var visibilityCheckInterval = setInterval(expandSessionWhenVisible, VISIBILITY_CHECK_DELAY);
        stopCallbacks.push(function() {
            clearInterval(visibilityCheckInterval);
        });
    };
    var isServerError = // ../../node_modules/.pnpm/@datadog+browser-core@4.42.2/node_modules/@datadog/browser-core/esm/tools/utils/responseUtils.js
    function isServerError(status) {
        return status >= 500;
    };
    var tryToClone = function tryToClone(response) {
        try {
            return response.clone();
        } catch (e2) {
            return;
        }
    };
    var sendWithRetryStrategy = function sendWithRetryStrategy(payload, state, sendStrategy, endpointType, reportError) {
        if (state.transportStatus === 0 && state.queuedPayloads.size() === 0 && state.bandwidthMonitor.canHandle(payload)) {
            send(payload, state, sendStrategy, {
                onSuccess: function onSuccess() {
                    return retryQueuedPayloads(0, state, sendStrategy, endpointType, reportError);
                },
                onFailure: function onFailure() {
                    state.queuedPayloads.enqueue(payload);
                    scheduleRetry(state, sendStrategy, endpointType, reportError);
                }
            });
        } else {
            state.queuedPayloads.enqueue(payload);
        }
    };
    var send = function send(payload, state, sendStrategy, _a4) {
        var onSuccess = _a4.onSuccess, onFailure = _a4.onFailure;
        state.bandwidthMonitor.add(payload);
        sendStrategy(payload, function(response) {
            state.bandwidthMonitor.remove(payload);
            if (!shouldRetryRequest(response)) {
                state.transportStatus = 0;
                onSuccess();
            } else {
                state.transportStatus = state.bandwidthMonitor.ongoingRequestCount > 0 ? 1 : 2;
                payload.retry = {
                    count: payload.retry ? payload.retry.count + 1 : 1,
                    lastFailureStatus: response.status
                };
                onFailure();
            }
        });
    };
    var retryQueuedPayloads = function retryQueuedPayloads(reason, state, sendStrategy, endpointType, reportError) {
        if (reason === 0 && state.queuedPayloads.isFull() && !state.queueFullReported) {
            reportError({
                message: "Reached max ".concat(endpointType, " events size queued for upload: ").concat(MAX_QUEUE_BYTES_COUNT / ONE_MEBI_BYTE, "MiB"),
                source: ErrorSource.AGENT,
                startClocks: clocksNow()
            });
            state.queueFullReported = true;
        }
        var previousQueue = state.queuedPayloads;
        state.queuedPayloads = newPayloadQueue();
        while(previousQueue.size() > 0){
            sendWithRetryStrategy(previousQueue.dequeue(), state, sendStrategy, endpointType, reportError);
        }
    };
    var shouldRetryRequest = function shouldRetryRequest(response) {
        return response.type !== "opaque" && (response.status === 0 && !navigator.onLine || response.status === 408 || response.status === 429 || isServerError(response.status));
    };
    var newRetryState = function newRetryState() {
        return {
            transportStatus: 0,
            currentBackoffTime: INITIAL_BACKOFF_TIME,
            bandwidthMonitor: newBandwidthMonitor(),
            queuedPayloads: newPayloadQueue(),
            queueFullReported: false
        };
    };
    var newPayloadQueue = function newPayloadQueue() {
        var queue = [];
        return {
            bytesCount: 0,
            enqueue: function enqueue(payload) {
                if (this.isFull()) {
                    return;
                }
                queue.push(payload);
                this.bytesCount += payload.bytesCount;
            },
            first: function first() {
                return queue[0];
            },
            dequeue: function dequeue() {
                var payload = queue.shift();
                if (payload) {
                    this.bytesCount -= payload.bytesCount;
                }
                return payload;
            },
            size: function size() {
                return queue.length;
            },
            isFull: function isFull() {
                return this.bytesCount >= MAX_QUEUE_BYTES_COUNT;
            }
        };
    };
    var newBandwidthMonitor = function newBandwidthMonitor() {
        return {
            ongoingRequestCount: 0,
            ongoingByteCount: 0,
            canHandle: function canHandle(payload) {
                return this.ongoingRequestCount === 0 || this.ongoingByteCount + payload.bytesCount <= MAX_ONGOING_BYTES_COUNT && this.ongoingRequestCount < MAX_ONGOING_REQUESTS;
            },
            add: function add(payload) {
                this.ongoingRequestCount += 1;
                this.ongoingByteCount += payload.bytesCount;
            },
            remove: function remove(payload) {
                this.ongoingRequestCount -= 1;
                this.ongoingByteCount -= payload.bytesCount;
            }
        };
    };
    var createHttpRequest = // ../../node_modules/.pnpm/@datadog+browser-core@4.42.2/node_modules/@datadog/browser-core/esm/transport/httpRequest.js
    function createHttpRequest(endpointBuilder, bytesLimit, reportError) {
        var retryState = newRetryState();
        var sendStrategyForRetry = function sendStrategyForRetry(payload, onResponse) {
            return fetchKeepAliveStrategy(endpointBuilder, bytesLimit, payload, onResponse);
        };
        return {
            send: function send(payload) {
                sendWithRetryStrategy(payload, retryState, sendStrategyForRetry, endpointBuilder.endpointType, reportError);
            },
            /**
       * Since fetch keepalive behaves like regular fetch on Firefox,
       * keep using sendBeaconStrategy on exit
       */ sendOnExit: function sendOnExit(payload) {
                sendBeaconStrategy(endpointBuilder, bytesLimit, payload);
            }
        };
    };
    var sendBeaconStrategy = function sendBeaconStrategy(endpointBuilder, bytesLimit, _a4) {
        var data = _a4.data, bytesCount = _a4.bytesCount, flushReason = _a4.flushReason;
        var canUseBeacon = !!navigator.sendBeacon && bytesCount < bytesLimit;
        if (canUseBeacon) {
            try {
                var beaconUrl = endpointBuilder.build("beacon", flushReason);
                var isQueued = navigator.sendBeacon(beaconUrl, data);
                if (isQueued) {
                    return;
                }
            } catch (e2) {
                reportBeaconError(e2);
            }
        }
        var xhrUrl = endpointBuilder.build("xhr", flushReason);
        sendXHR(xhrUrl, data);
    };
    var reportBeaconError = function reportBeaconError(e2) {
        if (!hasReportedBeaconError) {
            hasReportedBeaconError = true;
            addTelemetryError(e2);
        }
    };
    var fetchKeepAliveStrategy = function fetchKeepAliveStrategy(endpointBuilder, bytesLimit, _a4, onResponse) {
        var data = _a4.data, bytesCount = _a4.bytesCount, flushReason = _a4.flushReason, retry = _a4.retry;
        var canUseKeepAlive = isKeepAliveSupported() && bytesCount < bytesLimit;
        if (canUseKeepAlive) {
            var fetchUrl = endpointBuilder.build("fetch", flushReason, retry);
            fetch(fetchUrl, {
                method: "POST",
                body: data,
                keepalive: true,
                mode: "cors"
            }).then(monitor(function(response) {
                return onResponse === null || onResponse === void 0 ? void 0 : onResponse({
                    status: response.status,
                    type: response.type
                });
            }), monitor(function() {
                var xhrUrl2 = endpointBuilder.build("xhr", flushReason, retry);
                sendXHR(xhrUrl2, data, onResponse);
            }));
        } else {
            var xhrUrl = endpointBuilder.build("xhr", flushReason, retry);
            sendXHR(xhrUrl, data, onResponse);
        }
    };
    var isKeepAliveSupported = function isKeepAliveSupported() {
        try {
            return window.Request && "keepalive" in new Request("http://a");
        } catch (_a4) {
            return false;
        }
    };
    var sendXHR = function sendXHR(url, data, onResponse) {
        var request = new XMLHttpRequest();
        request.open("POST", url, true);
        addEventListener(request, "loadend", function() {
            onResponse === null || onResponse === void 0 ? void 0 : onResponse({
                status: request.status
            });
        }, {
            // prevent multiple onResponse callbacks
            // if the xhr instance is reused by a third party
            once: true
        });
        request.send(data);
    };
    var createPageExitObservable = function createPageExitObservable() {
        var observable = new Observable(function() {
            var pagehideEnabled = isExperimentalFeatureEnabled(ExperimentalFeature.PAGEHIDE);
            var stopListeners = addEventListeners(window, [
                "visibilitychange",
                "freeze",
                "pagehide"
            ], function(event) {
                if (event.type === "pagehide" && pagehideEnabled) {
                    observable.notify({
                        reason: PageExitReason.PAGEHIDE
                    });
                } else if (event.type === "visibilitychange" && document.visibilityState === "hidden") {
                    observable.notify({
                        reason: PageExitReason.HIDDEN
                    });
                } else if (event.type === "freeze") {
                    observable.notify({
                        reason: PageExitReason.FROZEN
                    });
                }
            }, {
                capture: true
            }).stop;
            var stopBeforeUnloadListener = noop;
            if (!pagehideEnabled) {
                stopBeforeUnloadListener = addEventListener(window, "beforeunload", function() {
                    observable.notify({
                        reason: PageExitReason.UNLOADING
                    });
                }).stop;
            }
            return function() {
                stopListeners();
                stopBeforeUnloadListener();
            };
        });
        return observable;
    };
    var isPageExitReason = function isPageExitReason(reason) {
        return includes(objectValues(PageExitReason), reason);
    };
    var getEventBridge = // ../../node_modules/.pnpm/@datadog+browser-core@4.42.2/node_modules/@datadog/browser-core/esm/transport/eventBridge.js
    function getEventBridge() {
        var eventBridgeGlobal = getEventBridgeGlobal();
        if (!eventBridgeGlobal) {
            return;
        }
        return {
            getAllowedWebViewHosts: function getAllowedWebViewHosts() {
                return JSON.parse(eventBridgeGlobal.getAllowedWebViewHosts());
            },
            send: function send(eventType, event) {
                eventBridgeGlobal.send(JSON.stringify({
                    eventType: eventType,
                    event: event
                }));
            }
        };
    };
    var canUseEventBridge = function canUseEventBridge(currentHost) {
        var _a4;
        if (currentHost === void 0) {
            currentHost = (_a4 = getGlobalObject().location) === null || _a4 === void 0 ? void 0 : _a4.hostname;
        }
        var bridge = getEventBridge();
        return !!bridge && bridge.getAllowedWebViewHosts().some(function(allowedHost) {
            return currentHost === allowedHost || endsWith(currentHost, ".".concat(allowedHost));
        });
    };
    var getEventBridgeGlobal = function getEventBridgeGlobal() {
        return getGlobalObject().DatadogEventBridge;
    };
    var createFlushController = // ../../node_modules/.pnpm/@datadog+browser-core@4.42.2/node_modules/@datadog/browser-core/esm/transport/flushController.js
    function createFlushController(_a4) {
        var messagesLimit = _a4.messagesLimit, bytesLimit = _a4.bytesLimit, durationLimit = _a4.durationLimit, pageExitObservable = _a4.pageExitObservable, sessionExpireObservable = _a4.sessionExpireObservable;
        var flushObservable = new Observable();
        pageExitObservable.subscribe(function(event) {
            return flush(event.reason);
        });
        sessionExpireObservable.subscribe(function() {
            return flush("session_expire");
        });
        var currentBytesCount = 0;
        var currentMessagesCount = 0;
        function flush(flushReason) {
            if (currentMessagesCount === 0) {
                return;
            }
            var messagesCount = currentMessagesCount;
            var bytesCount = currentBytesCount;
            currentMessagesCount = 0;
            currentBytesCount = 0;
            cancelDurationLimitTimeout();
            flushObservable.notify({
                reason: flushReason,
                messagesCount: messagesCount,
                bytesCount: bytesCount
            });
        }
        var durationLimitTimeoutId;
        function scheduleDurationLimitTimeout() {
            if (durationLimitTimeoutId === void 0) {
                durationLimitTimeoutId = setTimeout2(function() {
                    flush("duration_limit");
                }, durationLimit);
            }
        }
        function cancelDurationLimitTimeout() {
            clearTimeout2(durationLimitTimeoutId);
            durationLimitTimeoutId = void 0;
        }
        return {
            flushObservable: flushObservable,
            get messagesCount () {
                return currentMessagesCount;
            },
            /**
       * Notifies that a message will be added to a pool of pending messages waiting to be flushed.
       *
       * This function needs to be called synchronously, right before adding the message, so no flush
       * event can happen after `notifyBeforeAddMessage` and before adding the message.
       */ notifyBeforeAddMessage: function notifyBeforeAddMessage(messageBytesCount) {
                if (currentBytesCount + messageBytesCount >= bytesLimit) {
                    flush("bytes_limit");
                }
                currentMessagesCount += 1;
                currentBytesCount += messageBytesCount;
                scheduleDurationLimitTimeout();
            },
            /**
       * Notifies that a message *was* added to a pool of pending messages waiting to be flushed.
       *
       * This function can be called asynchronously after the message was added, but in this case it
       * should not be called if a flush event occurred in between.
       */ notifyAfterAddMessage: function notifyAfterAddMessage() {
                if (currentMessagesCount >= messagesLimit) {
                    flush("messages_limit");
                } else if (currentBytesCount >= bytesLimit) {
                    flush("bytes_limit");
                }
            },
            /**
       * Notifies that a message was removed from a pool of pending messages waiting to be flushed.
       *
       * This function needs to be called synchronously, right after removing the message, so no flush
       * event can happen after removing the message and before `notifyAfterRemoveMessage`.
       */ notifyAfterRemoveMessage: function notifyAfterRemoveMessage(messageBytesCount) {
                currentBytesCount -= messageBytesCount;
                currentMessagesCount -= 1;
                if (currentMessagesCount === 0) {
                    cancelDurationLimitTimeout();
                }
            }
        };
    };
    var startBatchWithReplica = // ../../node_modules/.pnpm/@datadog+browser-core@4.42.2/node_modules/@datadog/browser-core/esm/transport/startBatchWithReplica.js
    function startBatchWithReplica(configuration, endpoint, reportError, pageExitObservable, sessionExpireObservable, replicaEndpoint) {
        var primaryBatch = createBatch(endpoint);
        var replicaBatch;
        if (replicaEndpoint) {
            replicaBatch = createBatch(replicaEndpoint);
        }
        function createBatch(endpointBuilder) {
            return new Batch(createHttpRequest(endpointBuilder, configuration.batchBytesLimit, reportError), createFlushController({
                messagesLimit: configuration.batchMessagesLimit,
                bytesLimit: configuration.batchBytesLimit,
                durationLimit: configuration.flushTimeout,
                pageExitObservable: pageExitObservable,
                sessionExpireObservable: sessionExpireObservable
            }), configuration.messageBytesLimit);
        }
        return {
            add: function add(message, replicated) {
                if (replicated === void 0) {
                    replicated = true;
                }
                primaryBatch.add(message);
                if (replicaBatch && replicated) {
                    replicaBatch.add(message);
                }
            }
        };
    };
    var removeDuplicates = // ../../node_modules/.pnpm/@datadog+browser-core@4.42.2/node_modules/@datadog/browser-core/esm/tools/utils/arrayUtils.js
    function removeDuplicates(array) {
        var set = /* @__PURE__ */ new Set();
        array.forEach(function(item) {
            return set.add(item);
        });
        return arrayFrom(set);
    };
    var createEventRateLimiter = // ../../node_modules/.pnpm/@datadog+browser-core@4.42.2/node_modules/@datadog/browser-core/esm/domain/eventRateLimiter/createEventRateLimiter.js
    function createEventRateLimiter(eventType, limit, onLimitReached) {
        var eventCount = 0;
        var allowNextEvent = false;
        return {
            isLimitReached: function isLimitReached() {
                if (eventCount === 0) {
                    setTimeout2(function() {
                        eventCount = 0;
                    }, ONE_MINUTE);
                }
                eventCount += 1;
                if (eventCount <= limit || allowNextEvent) {
                    allowNextEvent = false;
                    return false;
                }
                if (eventCount === limit + 1) {
                    allowNextEvent = true;
                    try {
                        onLimitReached({
                            message: "Reached max number of ".concat(eventType, "s by minute: ").concat(limit),
                            source: ErrorSource.AGENT,
                            startClocks: clocksNow()
                        });
                    } finally{
                        allowNextEvent = false;
                    }
                }
                return true;
            }
        };
    };
    var initXhrObservable = function initXhrObservable() {
        if (!xhrObservable) {
            xhrObservable = createXhrObservable();
        }
        return xhrObservable;
    };
    var createXhrObservable = function createXhrObservable() {
        var observable = new Observable(function() {
            var stopInstrumentingStart = instrumentMethodAndCallOriginal(XMLHttpRequest.prototype, "open", {
                before: openXhr
            }).stop;
            var stopInstrumentingSend = instrumentMethodAndCallOriginal(XMLHttpRequest.prototype, "send", {
                before: function before() {
                    sendXhr.call(this, observable);
                }
            }).stop;
            var stopInstrumentingAbort = instrumentMethodAndCallOriginal(XMLHttpRequest.prototype, "abort", {
                before: abortXhr
            }).stop;
            return function() {
                stopInstrumentingStart();
                stopInstrumentingSend();
                stopInstrumentingAbort();
            };
        });
        return observable;
    };
    var openXhr = function openXhr(method, url) {
        xhrContexts.set(this, {
            state: "open",
            method: method,
            url: normalizeUrl(String(url))
        });
    };
    var sendXhr = function sendXhr(observable) {
        var _this = this;
        var context = xhrContexts.get(this);
        if (!context) {
            return;
        }
        var startContext = context;
        startContext.state = "start";
        startContext.startTime = relativeNow();
        startContext.startClocks = clocksNow();
        startContext.isAborted = false;
        startContext.xhr = this;
        var hasBeenReported = false;
        var stopInstrumentingOnReadyStateChange = instrumentMethodAndCallOriginal(this, "onreadystatechange", {
            before: function before() {
                if (this.readyState === XMLHttpRequest.DONE) {
                    onEnd();
                }
            }
        }).stop;
        var onEnd = function onEnd() {
            unsubscribeLoadEndListener();
            stopInstrumentingOnReadyStateChange();
            if (hasBeenReported) {
                return;
            }
            hasBeenReported = true;
            var completeContext = context;
            completeContext.state = "complete";
            completeContext.duration = elapsed(startContext.startClocks.timeStamp, timeStampNow());
            completeContext.status = _this.status;
            observable.notify(shallowClone(completeContext));
        };
        var unsubscribeLoadEndListener = addEventListener(this, "loadend", onEnd).stop;
        observable.notify(startContext);
    };
    var abortXhr = function abortXhr() {
        var context = xhrContexts.get(this);
        if (context) {
            context.isAborted = true;
        }
    };
    var initFetchObservable = function initFetchObservable() {
        if (!fetchObservable) {
            fetchObservable = createFetchObservable();
        }
        return fetchObservable;
    };
    var createFetchObservable = function createFetchObservable() {
        var observable = new Observable(function() {
            if (!window.fetch) {
                return;
            }
            var stop = instrumentMethod(window, "fetch", function(originalFetch) {
                return function(input, init) {
                    var responsePromise;
                    var context = callMonitored(beforeSend, null, [
                        observable,
                        input,
                        init
                    ]);
                    if (context) {
                        responsePromise = originalFetch.call(this, context.input, context.init);
                        callMonitored(afterSend, null, [
                            observable,
                            responsePromise,
                            context
                        ]);
                    } else {
                        responsePromise = originalFetch.call(this, input, init);
                    }
                    return responsePromise;
                };
            }).stop;
            return stop;
        });
        return observable;
    };
    var beforeSend = function beforeSend(observable, input, init) {
        var method = init && init.method || _instanceof(input, Request) && input.method || "GET";
        var url = _instanceof(input, Request) ? input.url : normalizeUrl(String(input));
        var startClocks = clocksNow();
        var context = {
            state: "start",
            init: init,
            input: input,
            method: method,
            startClocks: startClocks,
            url: url
        };
        observable.notify(context);
        return context;
    };
    var afterSend = function afterSend(observable, responsePromise, startContext) {
        var reportFetch = function reportFetch(response) {
            var context = startContext;
            context.state = "resolve";
            if ("stack" in response || _instanceof(response, Error)) {
                context.status = 0;
                context.isAborted = _instanceof(response, DOMException) && response.code === DOMException.ABORT_ERR;
                context.error = response;
            } else if ("status" in response) {
                context.response = response;
                context.responseType = response.type;
                context.status = response.status;
                context.isAborted = false;
            }
            observable.notify(context);
        };
        responsePromise.then(monitor(reportFetch), monitor(reportFetch));
    };
    var initConsoleObservable = function initConsoleObservable(apis) {
        var consoleObservables = apis.map(function(api) {
            if (!consoleObservablesByApi[api]) {
                consoleObservablesByApi[api] = createConsoleObservable(api);
            }
            return consoleObservablesByApi[api];
        });
        return mergeObservables.apply(void 0, consoleObservables);
    };
    var createConsoleObservable = function createConsoleObservable(api) {
        var observable = new Observable(function() {
            var originalConsoleApi = globalConsole[api];
            globalConsole[api] = function() {
                var params = [];
                for(var _i = 0; _i < arguments.length; _i++){
                    params[_i] = arguments[_i];
                }
                originalConsoleApi.apply(console, params);
                var handlingStack = createHandlingStack();
                callMonitored(function() {
                    observable.notify(buildConsoleLog(params, api, handlingStack));
                });
            };
            return function() {
                globalConsole[api] = originalConsoleApi;
            };
        });
        return observable;
    };
    var buildConsoleLog = function buildConsoleLog(params, api, handlingStack) {
        var message = params.map(function(param) {
            return formatConsoleParameters(param);
        }).join(" ");
        var stack;
        var fingerprint;
        if (api === ConsoleApiName.error) {
            var firstErrorParam = find(params, function(param) {
                return _instanceof(param, Error);
            });
            stack = firstErrorParam ? toStackTraceString(computeStackTrace(firstErrorParam)) : void 0;
            fingerprint = tryToGetFingerprint(firstErrorParam);
            message = "console error: ".concat(message);
        }
        return {
            api: api,
            message: message,
            stack: stack,
            handlingStack: handlingStack,
            fingerprint: fingerprint
        };
    };
    var formatConsoleParameters = function formatConsoleParameters(param) {
        if (typeof param === "string") {
            return sanitize(param);
        }
        if (_instanceof(param, Error)) {
            return formatErrorMessage(computeStackTrace(param));
        }
        return jsonStringify(sanitize(param), void 0, 2);
    };
    var warnIfCustomerDataLimitReached = function warnIfCustomerDataLimitReached(bytesCount, customerDataType) {
        if (bytesCount > CUSTOMER_DATA_BYTES_LIMIT) {
            display.warn("The ".concat(customerDataType, " data is over ").concat(CUSTOMER_DATA_BYTES_LIMIT / ONE_KIBI_BYTE, "KiB. On low connectivity, the SDK has the potential to exhaust the user's upload bandwidth."));
            return true;
        }
        return false;
    };
    var createContextManager = function createContextManager(customerDataType, computeBytesCountImpl) {
        if (computeBytesCountImpl === void 0) {
            computeBytesCountImpl = computeBytesCount;
        }
        var context = {};
        var bytesCountCache;
        var alreadyWarned = false;
        var computeBytesCountThrottled = throttle(function(context2) {
            bytesCountCache = computeBytesCountImpl(jsonStringify(context2));
            if (!alreadyWarned) {
                alreadyWarned = warnIfCustomerDataLimitReached(bytesCountCache, customerDataType);
            }
        }, BYTES_COMPUTATION_THROTTLING_DELAY).throttled;
        return {
            getBytesCount: function getBytesCount() {
                return bytesCountCache;
            },
            /** @deprecated use getContext instead */ get: function get() {
                return context;
            },
            /** @deprecated use setContextProperty instead */ add: function add(key, value) {
                context[key] = value;
                computeBytesCountThrottled(context);
            },
            /** @deprecated renamed to removeContextProperty */ remove: function remove(key) {
                delete context[key];
                computeBytesCountThrottled(context);
            },
            /** @deprecated use setContext instead */ set: function set(newContext) {
                context = newContext;
                computeBytesCountThrottled(context);
            },
            getContext: function getContext() {
                return deepClone(context);
            },
            setContext: function setContext(newContext) {
                context = sanitize(newContext);
                computeBytesCountThrottled(context);
            },
            setContextProperty: function setContextProperty(key, property) {
                context[key] = sanitize(property);
                computeBytesCountThrottled(context);
            },
            removeContextProperty: function removeContextProperty(key) {
                delete context[key];
                computeBytesCountThrottled(context);
            },
            clearContext: function clearContext() {
                context = {};
                bytesCountCache = 0;
            }
        };
    };
    var readBytesFromStream = // ../../node_modules/.pnpm/@datadog+browser-core@4.42.2/node_modules/@datadog/browser-core/esm/tools/readBytesFromStream.js
    function readBytesFromStream(stream, callback, options) {
        var reader = stream.getReader();
        var chunks = [];
        var readBytesCount = 0;
        readMore();
        function readMore() {
            reader.read().then(monitor(function(result) {
                if (result.done) {
                    onDone();
                    return;
                }
                if (options.collectStreamBody) {
                    chunks.push(result.value);
                }
                readBytesCount += result.value.length;
                if (readBytesCount > options.bytesLimit) {
                    onDone();
                } else {
                    readMore();
                }
            }), monitor(function(error) {
                return callback(error);
            }));
        }
        function onDone() {
            reader.cancel().catch(// we don't care if cancel fails, but we still need to catch the error to avoid reporting it
            // as an unhandled rejection
            noop);
            var bytes;
            var limitExceeded;
            if (options.collectStreamBody) {
                var completeBuffer_1;
                if (chunks.length === 1) {
                    completeBuffer_1 = chunks[0];
                } else {
                    completeBuffer_1 = new Uint8Array(readBytesCount);
                    var offset_1 = 0;
                    chunks.forEach(function(chunk) {
                        completeBuffer_1.set(chunk, offset_1);
                        offset_1 += chunk.length;
                    });
                }
                bytes = completeBuffer_1.slice(0, options.bytesLimit);
                limitExceeded = completeBuffer_1.length > options.bytesLimit;
            }
            callback(void 0, bytes, limitExceeded);
        }
    };
    var willSyntheticsInjectRum = function willSyntheticsInjectRum() {
        return Boolean(window._DATADOG_SYNTHETICS_INJECTS_RUM || getCookie(SYNTHETICS_INJECTS_RUM_COOKIE_NAME));
    };
    var getSyntheticsTestId = function getSyntheticsTestId() {
        var value = window._DATADOG_SYNTHETICS_PUBLIC_ID || getCookie(SYNTHETICS_TEST_ID_COOKIE_NAME);
        return typeof value === "string" ? value : void 0;
    };
    var getSyntheticsResultId = function getSyntheticsResultId() {
        var value = window._DATADOG_SYNTHETICS_RESULT_ID || getCookie(SYNTHETICS_RESULT_ID_COOKIE_NAME);
        return typeof value === "string" ? value : void 0;
    };
    var sanitizeUser = // ../../node_modules/.pnpm/@datadog+browser-core@4.42.2/node_modules/@datadog/browser-core/esm/domain/user/user.js
    function sanitizeUser(newUser) {
        var user = assign({}, newUser);
        var keys = [
            "id",
            "name",
            "email"
        ];
        keys.forEach(function(key) {
            if (key in user) {
                user[key] = String(user[key]);
            }
        });
        return user;
    };
    var checkUser = function checkUser(newUser) {
        var isValid = getType(newUser) === "object";
        if (!isValid) {
            display.error("Unsupported user:", newUser);
        }
        return isValid;
    };
    var validateAndBuildLogsConfiguration = function validateAndBuildLogsConfiguration(initConfiguration) {
        var baseConfiguration = validateAndBuildConfiguration(initConfiguration);
        var forwardConsoleLogs = validateAndBuildForwardOption(initConfiguration.forwardConsoleLogs, objectValues(ConsoleApiName), "Forward Console Logs");
        var forwardReports = validateAndBuildForwardOption(initConfiguration.forwardReports, objectValues(RawReportType), "Forward Reports");
        if (!baseConfiguration || !forwardConsoleLogs || !forwardReports) {
            return;
        }
        if (initConfiguration.forwardErrorsToLogs && !includes(forwardConsoleLogs, ConsoleApiName.error)) {
            forwardConsoleLogs.push(ConsoleApiName.error);
        }
        return assign({
            forwardErrorsToLogs: initConfiguration.forwardErrorsToLogs !== false,
            forwardConsoleLogs: forwardConsoleLogs,
            forwardReports: forwardReports,
            requestErrorResponseLengthLimit: DEFAULT_REQUEST_ERROR_RESPONSE_LENGTH_LIMIT
        }, baseConfiguration);
    };
    var validateAndBuildForwardOption = function validateAndBuildForwardOption(option, allowedValues, label) {
        if (option === void 0) {
            return [];
        }
        if (!(option === "all" || Array.isArray(option) && option.every(function(api) {
            return includes(allowedValues, api);
        }))) {
            display.error("".concat(label, ' should be "all" or an array with allowed values "').concat(allowedValues.join('", "'), '"'));
            return;
        }
        return option === "all" ? allowedValues : removeDuplicates(option);
    };
    var serializeLogsConfiguration = function serializeLogsConfiguration(configuration) {
        var baseSerializedInitConfiguration = serializeConfiguration(configuration);
        return assign({
            forward_errors_to_logs: configuration.forwardErrorsToLogs,
            forward_console_logs: configuration.forwardConsoleLogs,
            forward_reports: configuration.forwardReports
        }, baseSerializedInitConfiguration);
    };
    var makeLogsPublicApi = // ../../node_modules/.pnpm/@datadog+browser-logs@4.42.2/node_modules/@datadog/browser-logs/esm/boot/logsPublicApi.js
    function makeLogsPublicApi(startLogsImpl) {
        var isAlreadyInitialized = false;
        var globalContextManager = createContextManager("global context");
        var userContextManager = createContextManager("user");
        var customLoggers = {};
        var getInternalContextStrategy = function getInternalContextStrategy() {
            return void 0;
        };
        var beforeInitLoggerLog = new BoundedBuffer();
        var handleLogStrategy = function handleLogStrategy1(logsMessage, logger, savedCommonContext, date) {
            if (savedCommonContext === void 0) {
                savedCommonContext = deepClone(buildCommonContext());
            }
            if (date === void 0) {
                date = timeStampNow();
            }
            beforeInitLoggerLog.add(function() {
                return handleLogStrategy(logsMessage, logger, savedCommonContext, date);
            });
        };
        var getInitConfigurationStrategy = function getInitConfigurationStrategy() {
            return void 0;
        };
        var mainLogger = new Logger(function() {
            var params = [];
            for(var _i = 0; _i < arguments.length; _i++){
                params[_i] = arguments[_i];
            }
            return handleLogStrategy.apply(void 0, params);
        });
        function buildCommonContext() {
            return {
                view: {
                    referrer: document.referrer,
                    url: window.location.href
                },
                context: globalContextManager.getContext(),
                user: userContextManager.getContext()
            };
        }
        return makePublicApi({
            logger: mainLogger,
            init: monitor(function(initConfiguration) {
                var _a4;
                getInitConfigurationStrategy = function getInitConfigurationStrategy() {
                    return deepClone(initConfiguration);
                };
                if (canUseEventBridge()) {
                    initConfiguration = overrideInitConfigurationForBridge(initConfiguration);
                }
                if (!canInitLogs(initConfiguration)) {
                    return;
                }
                var configuration = validateAndBuildLogsConfiguration(initConfiguration);
                if (!configuration) {
                    return;
                }
                ;
                _a4 = startLogsImpl(initConfiguration, configuration, buildCommonContext, mainLogger), handleLogStrategy = _a4.handleLog, getInternalContextStrategy = _a4.getInternalContext;
                beforeInitLoggerLog.drain();
                isAlreadyInitialized = true;
            }),
            /** @deprecated: use getGlobalContext instead */ getLoggerGlobalContext: monitor(globalContextManager.get),
            getGlobalContext: monitor(globalContextManager.getContext),
            /** @deprecated: use setGlobalContext instead */ setLoggerGlobalContext: monitor(globalContextManager.set),
            setGlobalContext: monitor(globalContextManager.setContext),
            /** @deprecated: use setGlobalContextProperty instead */ addLoggerGlobalContext: monitor(globalContextManager.add),
            setGlobalContextProperty: monitor(globalContextManager.setContextProperty),
            /** @deprecated: use removeGlobalContextProperty instead */ removeLoggerGlobalContext: monitor(globalContextManager.remove),
            removeGlobalContextProperty: monitor(globalContextManager.removeContextProperty),
            clearGlobalContext: monitor(globalContextManager.clearContext),
            createLogger: monitor(function(name, conf) {
                if (conf === void 0) {
                    conf = {};
                }
                customLoggers[name] = new Logger(function() {
                    var params = [];
                    for(var _i = 0; _i < arguments.length; _i++){
                        params[_i] = arguments[_i];
                    }
                    return handleLogStrategy.apply(void 0, params);
                }, sanitize(name), conf.handler, conf.level, sanitize(conf.context));
                return customLoggers[name];
            }),
            getLogger: monitor(function(name) {
                return customLoggers[name];
            }),
            getInitConfiguration: monitor(function() {
                return getInitConfigurationStrategy();
            }),
            getInternalContext: monitor(function(startTime) {
                return getInternalContextStrategy(startTime);
            }),
            setUser: monitor(function(newUser) {
                if (checkUser(newUser)) {
                    userContextManager.setContext(sanitizeUser(newUser));
                }
            }),
            getUser: monitor(userContextManager.getContext),
            setUserProperty: monitor(function(key, property) {
                var _a4;
                var sanitizedProperty = sanitizeUser((_a4 = {}, _a4[key] = property, _a4))[key];
                userContextManager.setContextProperty(key, sanitizedProperty);
            }),
            removeUserProperty: monitor(userContextManager.removeContextProperty),
            clearUser: monitor(userContextManager.clearContext)
        });
        function overrideInitConfigurationForBridge(initConfiguration) {
            return assign({}, initConfiguration, {
                clientToken: "empty"
            });
        }
        function canInitLogs(initConfiguration) {
            if (isAlreadyInitialized) {
                if (!initConfiguration.silentMultipleInit) {
                    display.error("DD_LOGS is already initialized.");
                }
                return false;
            }
            return true;
        }
    };
    var startLogsSessionManager = function startLogsSessionManager(configuration) {
        var sessionManager = startSessionManager(configuration.cookieOptions, LOGS_SESSION_KEY2, function(rawTrackingType) {
            return computeSessionState(configuration, rawTrackingType);
        });
        return {
            findTrackedSession: function findTrackedSession(startTime) {
                var session = sessionManager.findActiveSession(startTime);
                return session && session.trackingType === "1" ? {
                    id: session.id
                } : void 0;
            },
            expireObservable: sessionManager.expireObservable
        };
    };
    var startLogsSessionManagerStub = function startLogsSessionManagerStub(configuration) {
        var isTracked = computeTrackingType(configuration) === "1";
        var session = isTracked ? {} : void 0;
        return {
            findTrackedSession: function findTrackedSession() {
                return session;
            },
            expireObservable: new Observable()
        };
    };
    var computeTrackingType = function computeTrackingType(configuration) {
        if (!performDraw(configuration.sessionSampleRate)) {
            return "0";
        }
        return "1";
    };
    var computeSessionState = function computeSessionState(configuration, rawSessionType) {
        var trackingType = hasValidLoggerSession(rawSessionType) ? rawSessionType : computeTrackingType(configuration);
        return {
            trackingType: trackingType,
            isTracked: trackingType === "1"
        };
    };
    var hasValidLoggerSession = function hasValidLoggerSession(trackingType) {
        return trackingType === "0" || trackingType === "1";
    };
    var startLoggerCollection = function startLoggerCollection(lifeCycle) {
        function handleLog(logsMessage, logger, savedCommonContext, savedDate) {
            var messageContext = logsMessage.context;
            if (isAuthorized(logsMessage.status, HandlerType.console, logger)) {
                display(logsMessage.status, logsMessage.message, combine(logger.getContext(), messageContext));
            }
            lifeCycle.notify(0, {
                rawLogsEvent: {
                    date: savedDate || timeStampNow(),
                    message: logsMessage.message,
                    status: logsMessage.status,
                    origin: ErrorSource.LOGGER
                },
                messageContext: messageContext,
                savedCommonContext: savedCommonContext,
                logger: logger
            });
        }
        return {
            handleLog: handleLog
        };
    };
    var isAuthorized = function isAuthorized(status, handlerType, logger) {
        var loggerHandler = logger.getHandler();
        var sanitizedHandlerType = Array.isArray(loggerHandler) ? loggerHandler : [
            loggerHandler
        ];
        return STATUS_PRIORITIES[status] >= STATUS_PRIORITIES[logger.getLevel()] && includes(sanitizedHandlerType, handlerType);
    };
    var startLogsAssembly = // ../../node_modules/.pnpm/@datadog+browser-logs@4.42.2/node_modules/@datadog/browser-logs/esm/domain/assembly.js
    function startLogsAssembly(sessionManager, configuration, lifeCycle, buildCommonContext, mainLogger, reportError) {
        var statusWithCustom = STATUSES.concat([
            "custom"
        ]);
        var logRateLimiters = {};
        statusWithCustom.forEach(function(status) {
            logRateLimiters[status] = createEventRateLimiter(status, configuration.eventRateLimiterThreshold, reportError);
        });
        lifeCycle.subscribe(0, function(_a4) {
            var _b, _c, _d;
            var rawLogsEvent = _a4.rawLogsEvent, _e = _a4.messageContext, messageContext = _e === void 0 ? void 0 : _e, _f = _a4.savedCommonContext, savedCommonContext = _f === void 0 ? void 0 : _f, _g = _a4.logger, logger = _g === void 0 ? mainLogger : _g;
            var startTime = getRelativeTime(rawLogsEvent.date);
            var session = sessionManager.findTrackedSession(startTime);
            if (!session) {
                return;
            }
            var commonContext = savedCommonContext || buildCommonContext();
            var log = combine({
                service: configuration.service,
                session_id: session.id,
                // Insert user first to allow overrides from global context
                usr: !isEmptyObject(commonContext.user) ? commonContext.user : void 0,
                view: commonContext.view
            }, commonContext.context, getRUMInternalContext(startTime), rawLogsEvent, logger.getContext(), messageContext);
            if (// Todo: [RUMF-1230] Move this check to the logger collection in the next major release
            !isAuthorized(rawLogsEvent.status, HandlerType.http, logger) || ((_b = configuration.beforeSend) === null || _b === void 0 ? void 0 : _b.call(configuration, log)) === false || ((_c = log.error) === null || _c === void 0 ? void 0 : _c.origin) !== ErrorSource.AGENT && ((_d = logRateLimiters[log.status]) !== null && _d !== void 0 ? _d : logRateLimiters["custom"]).isLimitReached()) {
                return;
            }
            lifeCycle.notify(1, log);
        });
    };
    var getRUMInternalContext = function getRUMInternalContext(startTime) {
        var browserWindow = window;
        if (willSyntheticsInjectRum()) {
            var context = getInternalContextFromRumGlobal(browserWindow.DD_RUM_SYNTHETICS);
            if (!context && !logsSentBeforeRumInjectionTelemetryAdded) {
                logsSentBeforeRumInjectionTelemetryAdded = true;
                addTelemetryDebug("Logs sent before RUM is injected by the synthetics worker", {
                    testId: getSyntheticsTestId(),
                    resultId: getSyntheticsResultId()
                });
            }
            return context;
        }
        return getInternalContextFromRumGlobal(browserWindow.DD_RUM);
        function getInternalContextFromRumGlobal(rumGlobal) {
            if (rumGlobal && rumGlobal.getInternalContext) {
                return rumGlobal.getInternalContext(startTime);
            }
        }
    };
    var startConsoleCollection = function startConsoleCollection(configuration, lifeCycle) {
        var consoleSubscription = initConsoleObservable(configuration.forwardConsoleLogs).subscribe(function(log) {
            lifeCycle.notify(0, {
                rawLogsEvent: {
                    date: timeStampNow(),
                    message: log.message,
                    origin: ErrorSource.CONSOLE,
                    error: log.api === ConsoleApiName.error ? {
                        origin: ErrorSource.CONSOLE,
                        stack: log.stack,
                        fingerprint: log.fingerprint
                    } : void 0,
                    status: LogStatusForApi[log.api]
                }
            });
        });
        return {
            stop: function stop() {
                consoleSubscription.unsubscribe();
            }
        };
    };
    var startReportCollection = function startReportCollection(configuration, lifeCycle) {
        var reportSubscription = initReportObservable(configuration.forwardReports).subscribe(function(report) {
            var message = report.message;
            var status = LogStatusForReport[report.type];
            var error;
            if (status === StatusType.error) {
                error = {
                    kind: report.subtype,
                    origin: ErrorSource.REPORT,
                    stack: report.stack
                };
            } else if (report.stack) {
                message += " Found in ".concat(getFileFromStackTraceString(report.stack));
            }
            lifeCycle.notify(0, {
                rawLogsEvent: {
                    date: timeStampNow(),
                    message: message,
                    origin: ErrorSource.REPORT,
                    error: error,
                    status: status
                }
            });
        });
        return {
            stop: function stop() {
                reportSubscription.unsubscribe();
            }
        };
    };
    var startNetworkErrorCollection = // ../../node_modules/.pnpm/@datadog+browser-logs@4.42.2/node_modules/@datadog/browser-logs/esm/domain/logsCollection/networkError/networkErrorCollection.js
    function startNetworkErrorCollection(configuration, lifeCycle) {
        if (!configuration.forwardErrorsToLogs) {
            return {
                stop: noop
            };
        }
        var xhrSubscription = initXhrObservable().subscribe(function(context) {
            if (context.state === "complete") {
                handleResponse("xhr", context);
            }
        });
        var fetchSubscription = initFetchObservable().subscribe(function(context) {
            if (context.state === "resolve") {
                handleResponse("fetch", context);
            }
        });
        function handleResponse(type, request) {
            if (!configuration.isIntakeUrl(request.url) && (isRejected(request) || isServerError(request.status))) {
                if ("xhr" in request) {
                    computeXhrResponseData(request.xhr, configuration, onResponseDataAvailable);
                } else if (request.response) {
                    computeFetchResponseText(request.response, configuration, onResponseDataAvailable);
                } else if (request.error) {
                    computeFetchErrorText(request.error, configuration, onResponseDataAvailable);
                }
            }
            function onResponseDataAvailable(responseData) {
                lifeCycle.notify(0, {
                    rawLogsEvent: {
                        message: "".concat(format(type), " error ").concat(request.method, " ").concat(request.url),
                        date: request.startClocks.timeStamp,
                        error: {
                            origin: ErrorSource.NETWORK,
                            stack: responseData || "Failed to load"
                        },
                        http: {
                            method: request.method,
                            status_code: request.status,
                            url: request.url
                        },
                        status: StatusType.error,
                        origin: ErrorSource.NETWORK
                    }
                });
            }
        }
        return {
            stop: function stop() {
                xhrSubscription.unsubscribe();
                fetchSubscription.unsubscribe();
            }
        };
    };
    var computeXhrResponseData = function computeXhrResponseData(xhr, configuration, callback) {
        if (typeof xhr.response === "string") {
            callback(truncateResponseText(xhr.response, configuration));
        } else {
            callback(xhr.response);
        }
    };
    var computeFetchErrorText = function computeFetchErrorText(error, configuration, callback) {
        callback(truncateResponseText(toStackTraceString(computeStackTrace(error)), configuration));
    };
    var computeFetchResponseText = function computeFetchResponseText(response, configuration, callback) {
        var clonedResponse = tryToClone(response);
        if (!clonedResponse || !clonedResponse.body) {
            callback();
        } else if (!window.TextDecoder) {
            clonedResponse.text().then(monitor(function(text) {
                return callback(truncateResponseText(text, configuration));
            }), monitor(function(error) {
                return callback("Unable to retrieve response: ".concat(error));
            }));
        } else {
            truncateResponseStream(clonedResponse.body, configuration.requestErrorResponseLengthLimit, function(error, responseText) {
                if (error) {
                    callback("Unable to retrieve response: ".concat(error));
                } else {
                    callback(responseText);
                }
            });
        }
    };
    var isRejected = function isRejected(request) {
        return request.status === 0 && request.responseType !== "opaque";
    };
    var truncateResponseText = function truncateResponseText(responseText, configuration) {
        if (responseText.length > configuration.requestErrorResponseLengthLimit) {
            return "".concat(responseText.substring(0, configuration.requestErrorResponseLengthLimit), "...");
        }
        return responseText;
    };
    var format = function format(type) {
        if ("xhr" === type) {
            return "XHR";
        }
        return "Fetch";
    };
    var truncateResponseStream = function truncateResponseStream(stream, bytesLimit, callback) {
        readBytesFromStream(stream, function(error, bytes, limitExceeded) {
            if (error) {
                callback(error);
            } else {
                var responseText = new TextDecoder().decode(bytes);
                if (limitExceeded) {
                    responseText += "...";
                }
                callback(void 0, responseText);
            }
        }, {
            bytesLimit: bytesLimit,
            collectStreamBody: true
        });
    };
    var startRuntimeErrorCollection = // ../../node_modules/.pnpm/@datadog+browser-logs@4.42.2/node_modules/@datadog/browser-logs/esm/domain/logsCollection/runtimeError/runtimeErrorCollection.js
    function startRuntimeErrorCollection(configuration, lifeCycle) {
        if (!configuration.forwardErrorsToLogs) {
            return {
                stop: noop
            };
        }
        var rawErrorObservable = new Observable();
        var stopRuntimeErrorTracking = trackRuntimeError(rawErrorObservable).stop;
        var rawErrorSubscription = rawErrorObservable.subscribe(function(rawError) {
            lifeCycle.notify(0, {
                rawLogsEvent: {
                    message: rawError.message,
                    date: rawError.startClocks.timeStamp,
                    error: {
                        kind: rawError.type,
                        origin: ErrorSource.SOURCE,
                        stack: rawError.stack
                    },
                    origin: ErrorSource.SOURCE,
                    status: StatusType.error
                }
            });
        });
        return {
            stop: function stop() {
                stopRuntimeErrorTracking();
                rawErrorSubscription.unsubscribe();
            }
        };
    };
    var startLogsBatch = // ../../node_modules/.pnpm/@datadog+browser-logs@4.42.2/node_modules/@datadog/browser-logs/esm/transport/startLogsBatch.js
    function startLogsBatch(configuration, lifeCycle, reportError, pageExitObservable, sessionExpireObservable) {
        var _a4;
        var batch = startBatchWithReplica(configuration, configuration.logsEndpointBuilder, reportError, pageExitObservable, sessionExpireObservable, (_a4 = configuration.replica) === null || _a4 === void 0 ? void 0 : _a4.logsEndpointBuilder);
        lifeCycle.subscribe(1, function(serverLogsEvent) {
            batch.add(serverLogsEvent);
        });
    };
    var startLogsBridge = // ../../node_modules/.pnpm/@datadog+browser-logs@4.42.2/node_modules/@datadog/browser-logs/esm/transport/startLogsBridge.js
    function startLogsBridge(lifeCycle) {
        var bridge = getEventBridge();
        lifeCycle.subscribe(1, function(serverLogsEvent) {
            bridge.send("log", serverLogsEvent);
        });
    };
    var startInternalContext = // ../../node_modules/.pnpm/@datadog+browser-logs@4.42.2/node_modules/@datadog/browser-logs/esm/domain/internalContext.js
    function startInternalContext(sessionManager) {
        return {
            get: function get(startTime) {
                var trackedSession = sessionManager.findTrackedSession(startTime);
                if (trackedSession) {
                    return {
                        session_id: trackedSession.id
                    };
                }
            }
        };
    };
    var startLogs = // ../../node_modules/.pnpm/@datadog+browser-logs@4.42.2/node_modules/@datadog/browser-logs/esm/boot/startLogs.js
    function startLogs(initConfiguration, configuration, buildCommonContext, mainLogger) {
        var lifeCycle = new LifeCycle();
        lifeCycle.subscribe(1, function(log) {
            return sendToExtension("logs", log);
        });
        var reportError = function reportError(error) {
            return lifeCycle.notify(0, {
                rawLogsEvent: {
                    message: error.message,
                    date: error.startClocks.timeStamp,
                    error: {
                        origin: ErrorSource.AGENT
                    },
                    origin: ErrorSource.AGENT,
                    status: StatusType.error
                }
            });
        };
        var pageExitObservable = createPageExitObservable();
        var session = areCookiesAuthorized(configuration.cookieOptions) && !canUseEventBridge() && !willSyntheticsInjectRum() ? startLogsSessionManager(configuration) : startLogsSessionManagerStub(configuration);
        var telemetry = startLogsTelemetry(configuration, reportError, pageExitObservable, session.expireObservable);
        telemetry.setContextProvider(function() {
            var _a4, _b, _c, _d, _e, _f;
            return {
                application: {
                    id: (_a4 = getRUMInternalContext()) === null || _a4 === void 0 ? void 0 : _a4.application_id
                },
                session: {
                    id: (_b = session.findTrackedSession()) === null || _b === void 0 ? void 0 : _b.id
                },
                view: {
                    id: (_d = (_c = getRUMInternalContext()) === null || _c === void 0 ? void 0 : _c.view) === null || _d === void 0 ? void 0 : _d.id
                },
                action: {
                    id: (_f = (_e = getRUMInternalContext()) === null || _e === void 0 ? void 0 : _e.user_action) === null || _f === void 0 ? void 0 : _f.id
                }
            };
        });
        startNetworkErrorCollection(configuration, lifeCycle);
        startRuntimeErrorCollection(configuration, lifeCycle);
        startConsoleCollection(configuration, lifeCycle);
        startReportCollection(configuration, lifeCycle);
        var handleLog = startLoggerCollection(lifeCycle).handleLog;
        startLogsAssembly(session, configuration, lifeCycle, buildCommonContext, mainLogger, reportError);
        if (!canUseEventBridge()) {
            startLogsBatch(configuration, lifeCycle, reportError, pageExitObservable, session.expireObservable);
        } else {
            startLogsBridge(lifeCycle);
        }
        addTelemetryConfiguration(serializeLogsConfiguration(initConfiguration));
        var internalContext = startInternalContext(session);
        return {
            handleLog: handleLog,
            getInternalContext: internalContext.get
        };
    };
    var startLogsTelemetry = function startLogsTelemetry(configuration, reportError, pageExitObservable, sessionExpireObservable) {
        var _a4;
        var telemetry = startTelemetry("browser-logs-sdk", configuration);
        if (canUseEventBridge()) {
            var bridge_1 = getEventBridge();
            telemetry.observable.subscribe(function(event) {
                return bridge_1.send("internal_telemetry", event);
            });
        } else {
            var telemetryBatch_1 = startBatchWithReplica(configuration, configuration.rumEndpointBuilder, reportError, pageExitObservable, sessionExpireObservable, (_a4 = configuration.replica) === null || _a4 === void 0 ? void 0 : _a4.rumEndpointBuilder);
            telemetry.observable.subscribe(function(event) {
                return telemetryBatch_1.add(event, isTelemetryReplicationAllowed(configuration));
            });
        }
        return telemetry;
    };
    var __getOwnPropNames = Object.getOwnPropertyNames;
    var __commonJS = function(cb, mod) {
        return function __require() {
            return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = {
                exports: {}
            }).exports, mod), mod.exports;
        };
    };
    // ../risk-js/package.json
    var require_package = __commonJS({
        "../risk-js/package.json": function(exports, module) {
            module.exports = {
                name: "@cko/risk",
                version: "1.7.0",
                license: "MIT",
                main: "dist/risk.cjs.js",
                types: "dist/types/src/index.d.ts",
                module: "dist/risk-js.esm.js",
                source: "src/index.ts",
                files: [
                    "dist",
                    "src"
                ],
                engines: {
                    node: ">=10"
                },
                scripts: {
                    prebuild: "rm -rf ./dist",
                    build: "NODE_ENV=prod rollup -c",
                    "build:dev": "NODE_ENV=dev rollup -c",
                    postbuild: "pnpm tsc --emitDeclarationOnly && node package-size",
                    "clean:modules": "rm -rf node_modules",
                    "clean:build": "rm -rf dist",
                    clean: "pnpm clean:modules && pnpm clean:build",
                    test: "pnpm jest",
                    lint: "eslint 'src/**/*.{ts,tsx}'",
                    prepublishOnly: "pnpm build",
                    size: "size-limit",
                    analyze: "size-limit --why",
                    dev: "pnpm build:dev && pnpm parcel dev/index.html --port 4000",
                    typescript: "tsc"
                },
                husky: {
                    hooks: {
                        "pre-commit": "pnpm lint"
                    }
                },
                prettier: {
                    printWidth: 80,
                    semi: true,
                    singleQuote: true,
                    trailingComma: "es5"
                },
                author: "cko-prism",
                "size-limit": [
                    {
                        path: "dist/risk-js.cjs.production.min.js",
                        limit: "20 KB"
                    },
                    {
                        path: "dist/risk-js.esm.js",
                        limit: "20 KB"
                    }
                ],
                devDependencies: {
                    "@babel/preset-env": "^7.20.2",
                    "@babel/preset-typescript": "^7.21.0",
                    "@risk/eslint-config": "workspace:*",
                    "@rollup/plugin-node-resolve": "^11.2.1",
                    "@rollup/plugin-terser": "0.4.4",
                    "@rollup/plugin-typescript": "8.2.1",
                    "@size-limit/preset-small-lib": "^4.10.2",
                    "@swc/core": "^1.3.39",
                    "@types/jest": "^29.2.2",
                    "@types/node": "^18.11.9",
                    "@types/node-fetch": "^2.5.10",
                    "@types/uuid": "^8.3.0",
                    dotenv: "^8.2.0",
                    eslint: "7.32.0",
                    husky: "^6.0.0",
                    jest: "^29.3.1",
                    "minified-size": "^2.2.0",
                    parcel: "2.9.3",
                    prettier: "^2.7.1",
                    rollup: "^1.32.1",
                    "size-limit": "^4.10.2",
                    "ts-jest": "^29.0.3",
                    tslib: "^2.4.1",
                    typescript: "^4.2.4"
                },
                dependencies: {
                    "@fingerprintjs/fingerprintjs-pro": "3.8.5",
                    "whatwg-fetch": "3.6.2",
                    "yet-another-abortcontroller-polyfill": "0.0.4"
                }
            };
        }
    });
    // ../risk-js/dist/risk-js.esm.js
    var t = "undefined" != typeof globalThis && globalThis || "undefined" != typeof self && self || "undefined" != typeof global && global;
    if (void 0 === t.AbortController) {
        var e2 = {};
        t.AbortSignal = function() {
            function t2(t3) {
                if (t3 !== e2) throw new TypeError("Illegal constructor.");
                EventTarget.call(this), this._aborted = false;
            }
            return t2.prototype = Object.create(EventTarget.prototype), t2.prototype.constructor = t2, Object.defineProperty(t2.prototype, "onabort", {
                get: function get() {
                    return this._onabort;
                },
                set: function set(t3) {
                    var e3 = this._onabort;
                    e3 && this.removeEventListener("abort", e3), this._onabort = t3, this.addEventListener("abort", t3);
                }
            }), Object.defineProperty(t2.prototype, "aborted", {
                get: function get() {
                    return this._aborted;
                }
            }), t2;
        }(), t.AbortController = function() {
            function t2() {
                this._signal = new AbortSignal(e2);
            }
            return t2.prototype = Object.create(Object.prototype), Object.defineProperty(t2.prototype, "signal", {
                get: function get() {
                    return this._signal;
                }
            }), t2.prototype.abort = function() {
                var t3 = this.signal;
                t3.aborted || (t3._aborted = true, t3.dispatchEvent(new Event("abort")));
            }, t2;
        }();
    }
    var e = "undefined" != typeof globalThis && globalThis || "undefined" != typeof self && self || void 0 !== e && e;
    var r = "URLSearchParams" in e;
    var n = "Symbol" in e && "iterator" in Symbol;
    var i = "FileReader" in e && "Blob" in e && function() {
        try {
            return new Blob(), true;
        } catch (t2) {
            return false;
        }
    }();
    var o = "FormData" in e;
    var s = "ArrayBuffer" in e;
    if (s) var a = [
        "[object Int8Array]",
        "[object Uint8Array]",
        "[object Uint8ClampedArray]",
        "[object Int16Array]",
        "[object Uint16Array]",
        "[object Int32Array]",
        "[object Uint32Array]",
        "[object Float32Array]",
        "[object Float64Array]"
    ], u = ArrayBuffer.isView || function(t2) {
        return t2 && a.indexOf(Object.prototype.toString.call(t2)) > -1;
    };
    function d(t2) {
        this.map = {}, _instanceof(t2, d) ? t2.forEach(function(t3, e2) {
            this.append(e2, t3);
        }, this) : Array.isArray(t2) ? t2.forEach(function(t3) {
            this.append(t3[0], t3[1]);
        }, this) : t2 && Object.getOwnPropertyNames(t2).forEach(function(e2) {
            this.append(e2, t2[e2]);
        }, this);
    }
    d.prototype.append = function(t2, e2) {
        t2 = c(t2), e2 = l(e2);
        var r2 = this.map[t2];
        this.map[t2] = r2 ? r2 + ", " + e2 : e2;
    }, d.prototype.delete = function(t2) {
        delete this.map[c(t2)];
    }, d.prototype.get = function(t2) {
        return t2 = c(t2), this.has(t2) ? this.map[t2] : null;
    }, d.prototype.has = function(t2) {
        return this.map.hasOwnProperty(c(t2));
    }, d.prototype.set = function(t2, e2) {
        this.map[c(t2)] = l(e2);
    }, d.prototype.forEach = function(t2, e2) {
        for(var r2 in this.map)this.map.hasOwnProperty(r2) && t2.call(e2, this.map[r2], r2, this);
    }, d.prototype.keys = function() {
        var t2 = [];
        return this.forEach(function(e2, r2) {
            t2.push(r2);
        }), h(t2);
    }, d.prototype.values = function() {
        var t2 = [];
        return this.forEach(function(e2) {
            t2.push(e2);
        }), h(t2);
    }, d.prototype.entries = function() {
        var t2 = [];
        return this.forEach(function(e2, r2) {
            t2.push([
                r2,
                e2
            ]);
        }), h(t2);
    }, n && (d.prototype[Symbol.iterator] = d.prototype.entries);
    var m = [
        "DELETE",
        "GET",
        "HEAD",
        "OPTIONS",
        "POST",
        "PUT"
    ];
    function R(t2, e2) {
        if (!_instanceof(this, R)) throw new TypeError('Please use the "new" operator, this DOM object constructor cannot be called as a function.');
        var r2, n2, i2 = (e2 = e2 || {}).body;
        if (_instanceof(t2, R)) {
            if (t2.bodyUsed) throw new TypeError("Already read");
            this.url = t2.url, this.credentials = t2.credentials, e2.headers || (this.headers = new d(t2.headers)), this.method = t2.method, this.mode = t2.mode, this.signal = t2.signal, i2 || null == t2._bodyInit || (i2 = t2._bodyInit, t2.bodyUsed = true);
        } else this.url = String(t2);
        if (this.credentials = e2.credentials || this.credentials || "same-origin", !e2.headers && this.headers || (this.headers = new d(e2.headers)), this.method = (r2 = e2.method || this.method || "GET", n2 = r2.toUpperCase(), m.indexOf(n2) > -1 ? n2 : r2), this.mode = e2.mode || this.mode || null, this.signal = e2.signal || this.signal, this.referrer = null, ("GET" === this.method || "HEAD" === this.method) && i2) throw new TypeError("Body not allowed for GET or HEAD requests");
        if (this._initBody(i2), !("GET" !== this.method && "HEAD" !== this.method || "no-store" !== e2.cache && "no-cache" !== e2.cache)) {
            var o2 = /([?&])_=[^&]*/;
            if (o2.test(this.url)) this.url = this.url.replace(o2, "$1_=" + /* @__PURE__ */ new Date().getTime());
            else {
                this.url += (/\?/.test(this.url) ? "&" : "?") + "_=" + /* @__PURE__ */ new Date().getTime();
            }
        }
    }
    function w(t2, e2) {
        if (!_instanceof(this, w)) throw new TypeError('Please use the "new" operator, this DOM object constructor cannot be called as a function.');
        e2 || (e2 = {}), this.type = "default", this.status = void 0 === e2.status ? 200 : e2.status, this.ok = this.status >= 200 && this.status < 300, this.statusText = void 0 === e2.statusText ? "" : "" + e2.statusText, this.headers = new d(e2.headers), this.url = e2.url || "", this._initBody(t2);
    }
    R.prototype.clone = function() {
        return new R(this, {
            body: this._bodyInit
        });
    }, v.call(R.prototype), v.call(w.prototype), w.prototype.clone = function() {
        return new w(this._bodyInit, {
            status: this.status,
            statusText: this.statusText,
            headers: new d(this.headers),
            url: this.url
        });
    }, w.error = function() {
        var t2 = new w(null, {
            status: 0,
            statusText: ""
        });
        return t2.type = "error", t2;
    };
    var g = [
        301,
        302,
        303,
        307,
        308
    ];
    w.redirect = function(t2, e2) {
        if (-1 === g.indexOf(e2)) throw new RangeError("Invalid status code");
        return new w(null, {
            status: e2,
            headers: {
                location: t2
            }
        });
    };
    var _ = e.DOMException;
    try {
        new _();
    } catch (t2) {
        (_ = function _(t3, e2) {
            this.message = t3, this.name = e2;
            var r2 = Error(t3);
            this.stack = r2.stack;
        }).prototype = Object.create(Error.prototype), _.prototype.constructor = _;
    }
    T.polyfill = true, e.fetch || (e.fetch = T, e.Headers = d, e.Request = R, e.Response = w);
    var D = function D1(t2, e2) {
        return D = Object.setPrototypeOf || _instanceof({
            __proto__: []
        }, Array) && function(t3, e3) {
            t3.__proto__ = e3;
        } || function(t3, e3) {
            for(var r2 in e3)Object.prototype.hasOwnProperty.call(e3, r2) && (t3[r2] = e3[r2]);
        }, D(t2, e2);
    };
    var O = function O1() {
        return O = Object.assign || function(t2) {
            for(var e2, r2 = 1, n2 = arguments.length; r2 < n2; r2++)for(var i2 in e2 = arguments[r2])Object.prototype.hasOwnProperty.call(e2, i2) && (t2[i2] = e2[i2]);
            return t2;
        }, O.apply(this, arguments);
    };
    var I;
    !function(t2) {
        t2.CardToken = "card_token", t2.RiskJS = "riskjs";
    }(I || (I = {}));
    var A = function() {
        function t2(t3) {
            var e2 = t3.framesMode, r2 = t3.dataCollectors, n2 = void 0 === r2 ? [] : r2;
            this.dataCollectors = n2, this.framesMode = e2, this.deviceSessionId = null, this.fingerprintRequestId = null;
        }
        return t2.prototype.publishData = function(t3) {
            return P(this, void 0, void 0, function() {
                var e2, r2, n2, i2 = this;
                return k(this, function(o2) {
                    switch(o2.label){
                        case 0:
                            return e2 = this.deviceSessionId && this.fingerprintRequestId, e2 && !this.framesMode ? [
                                2,
                                Promise.resolve(this.deviceSessionId)
                            ] : e2 ? [
                                3,
                                2
                            ] : [
                                4,
                                Promise.all(this.dataCollectors.map(function(e3) {
                                    return i2.framesMode ? e3.publishData(I.CardToken, t3) : e3.publishData(I.RiskJS);
                                }))
                            ];
                        case 1:
                            return (r2 = o2.sent()[0]) && (this.deviceSessionId = r2.deviceSessionId, this.fingerprintRequestId = r2.fingerprintRequestId), [
                                2,
                                this.deviceSessionId
                            ];
                        case 2:
                            return [
                                4,
                                this.dataCollectors[0].persistDeviceData({
                                    requestId: this.fingerprintRequestId,
                                    sourceType: I.CardToken,
                                    cardToken: t3
                                })
                            ];
                        case 3:
                            return n2 = o2.sent(), this.deviceSessionId = n2, [
                                2,
                                this.deviceSessionId
                            ];
                    }
                });
            });
        }, t2;
    }();
    var B = "Blocked by CSP";
    var j = S("WrongRegion");
    var C = S("SubscriptionNotActive");
    var F = S("UnsupportedVersion");
    var N = S("InstallationMethodRestricted");
    var U = "API key required";
    var x = "API key not found";
    var q = "API key expired";
    var L = "9319";
    var K = "https://fpnpmcdn.net/v<version>/<apiKey>/loader_v<loaderVersion>.js";
    var J = "Failed to load the JS script of the agent";
    var W;
    var X = {
        load: function load(t2) {
            var e2;
            t2.scriptUrlPattern;
            var r2 = t2.token, n2 = t2.apiKey, i2 = void 0 === n2 ? r2 : n2, o2 = function(t3, e3) {
                var r3 = {};
                for(var n3 in t3)Object.prototype.hasOwnProperty.call(t3, n3) && e3.indexOf(n3) < 0 && (r3[n3] = t3[n3]);
                if (null != t3 && "function" == typeof Object.getOwnPropertySymbols) {
                    var i3 = 0;
                    for(n3 = Object.getOwnPropertySymbols(t3); i3 < n3.length; i3++)e3.indexOf(n3[i3]) < 0 && Object.prototype.propertyIsEnumerable.call(t3, n3[i3]) && (r3[n3[i3]] = t3[n3[i3]]);
                }
                return r3;
            }(t2, [
                "scriptUrlPattern",
                "token",
                "apiKey"
            ]), s2 = null !== (e2 = function(t3, e3) {
                return function(t4, e4) {
                    return Object.prototype.hasOwnProperty.call(t4, e4);
                }(t3, e3) ? t3[e3] : void 0;
            }(t2, "scriptUrlPattern")) && void 0 !== e2 ? e2 : K;
            return Promise.resolve().then(function() {
                if (!i2 || "string" != typeof i2) throw new Error(U);
                return M(function(t3, e3) {
                    return (Array.isArray(t3) ? t3 : [
                        t3
                    ]).map(function(t4) {
                        return function(t5, e4) {
                            var r3 = encodeURIComponent;
                            return t5.replace(/<[^<>]+>/g, function(t6) {
                                return "<version>" === t6 ? "3" : "<apiKey>" === t6 ? r3(e4) : "<loaderVersion>" === t6 ? r3("3.8.5") : t6;
                            });
                        }(String(t4), e3);
                    });
                }(s2, i2), H).catch(G);
            }).then(function(t3) {
                var e3 = t3[0], r3 = t3[1];
                return e3.load(O(O({}, o2), {
                    ldi: r3
                }));
            });
        },
        defaultScriptUrlPattern: K,
        ERROR_SCRIPT_LOAD_FAIL: J,
        ERROR_API_KEY_EXPIRED: q,
        ERROR_API_KEY_INVALID: x,
        ERROR_API_KEY_MISSING: U,
        ERROR_BAD_REQUEST_FORMAT: "Request cannot be parsed",
        ERROR_BAD_RESPONSE_FORMAT: "Response cannot be parsed",
        ERROR_CLIENT_TIMEOUT: "Client timeout",
        ERROR_CSP_BLOCK: B,
        ERROR_FORBIDDEN_ENDPOINT: S("HostnameRestricted"),
        ERROR_FORBIDDEN_HEADER: "Not available with restricted header",
        ERROR_FORBIDDEN_ORIGIN: "Not available for this origin",
        ERROR_GENERAL_SERVER_FAILURE: "Request failed",
        ERROR_INSTALLATION_METHOD_RESTRICTED: N,
        ERROR_INTEGRATION_FAILURE: S("IntegrationFailed"),
        ERROR_INVALID_ENDPOINT: "The endpoint parameter is not a valid URL",
        ERROR_NETWORK_ABORT: "Network request aborted",
        ERROR_NETWORK_CONNECTION: "Network connection error",
        ERROR_RATE_LIMIT: "Too many requests, rate limit exceeded",
        ERROR_SERVER_TIMEOUT: "Request failed to process",
        ERROR_SUBSCRIPTION_NOT_ACTIVE: C,
        ERROR_TOKEN_EXPIRED: q,
        ERROR_TOKEN_INVALID: x,
        ERROR_TOKEN_MISSING: U,
        ERROR_UNSUPPORTED_VERSION: F,
        ERROR_WRONG_REGION: j,
        defaultEndpoint: {
            default: "endpoint"
        },
        defaultTlsEndpoint: {
            default: "tlsEndpoint"
        }
    };
    var Y = function Y(t2) {
        for(var e2 = [], r2 = 1; r2 < arguments.length; r2++)e2[r2 - 1] = arguments[r2];
        t2.forEach(function(t3) {
            t3.apply(void 0, e2);
        });
    };
    var z = function z(t2) {
        return Object.keys(t2);
    };
    var $ = function(t2) {
        function e2(r2, n2, i2) {
            var o2 = t2.call(this) || this;
            return o2.message = r2, o2.code = n2, o2.response = i2, Object.setPrototypeOf(o2, e2.prototype), o2;
        }
        return function(t3, e3) {
            if ("function" != typeof e3 && null !== e3) throw new TypeError("Class extends value " + String(e3) + " is not a constructor or null");
            function r2() {
                this.constructor = t3;
            }
            D(t3, e3), t3.prototype = null === e3 ? Object.create(e3) : (r2.prototype = e3.prototype, new r2());
        }(e2, t2), e2;
    }(Error);
    !function(t2) {
        t2.RiskJsStandalone = "RiskJsStandalone", t2.RiskJsInFramesJs = "RiskJsInFramesJs";
    }(W || (W = {}));
    var Z;
    var tt = "".concat("https://fpjsworker.checkout.com/vKdHeO12gpAymiKK/gWsdhYyK8qHVJMEp", "?apiKey=<apiKey>&version=<version>&loaderVersion=<loaderVersion>");
    var et = function() {
        function t2(t3, e2) {
            var r2 = e2.onDataCollected, n2 = e2.onDataPublishBlocked, i2 = e2.onDataPublishFailure, o2 = e2.onDataPublished, s2 = e2.onDataDisabled, a2 = this;
            this.fingerprintAgent = null, this.loadTime = null, this.blockTime = null, this.fpPublishTime = null, this.deviceDataPersistTime = null, this.deviceSessionId = null, this.fingerprintRequestId = null, this.status = "pending", this.fingerprintPublicKey = "", this.onDataPublishFailure = i2, this.onDataPublished = o2, this.onDataPublishBlocked = n2, this.onDataDisabled = s2, this.deviceDataEndpoint = t3.deviceDataEndpoint, this.riskEndpoint = t3.riskEndpoint, this.publicKey = t3.publicKey, this.framesMode = t3.framesMode, this.riskCallsBlockedPromise = this.createRiskCallsBlockedPromise(this.framesMode ? W.RiskJsInFramesJs : W.RiskJsStandalone);
            var u2 = performance.now();
            this.riskCallsBlockedPromise.then(function() {
                return P(a2, void 0, void 0, function() {
                    var t4, e3, n3 = this;
                    return k(this, function(i3) {
                        return t4 = performance.now(), this.blockTime = t4 - u2, e3 = performance.now(), this.loadFingerprintJS().then(function(t5) {
                            var i4 = performance.now();
                            n3.loadTime = i4 - e3, r2(), n3.fingerprintAgent = t5;
                        }), [
                            2
                        ];
                    });
                });
            });
        }
        return t2.prototype.loadFingerprintJS = function() {
            return P(this, void 0, void 0, function() {
                return k(this, function(t3) {
                    return "disabled" === this.status || "blocked" === this.status ? [
                        2,
                        null
                    ] : [
                        2,
                        X.load({
                            apiKey: this.fingerprintPublicKey,
                            endpoint: this.riskEndpoint,
                            scriptUrlPattern: [
                                tt,
                                X.defaultScriptUrlPattern
                            ],
                            region: "eu"
                        })
                    ];
                });
            });
        }, t2.prototype.publishData = function(t3, e2) {
            return P(this, void 0, void 0, function() {
                var r2, n2, i2, o2;
                return k(this, function(s2) {
                    switch(s2.label){
                        case 0:
                            return [
                                4,
                                this.riskCallsBlockedPromise
                            ];
                        case 1:
                            if (s2.sent(), "blocked" === this.status) throw new Error("risk.js calls blocked");
                            if ("disabled" === this.status) return this.onDataDisabled(), [
                                2,
                                null
                            ];
                            if ("published" === this.status) return [
                                2,
                                {
                                    deviceSessionId: this.deviceSessionId,
                                    fingerprintRequestId: this.fingerprintRequestId
                                }
                            ];
                            r2 = {
                                tag: (a2 = t3, {
                                    fpjsSource: a2,
                                    fpjsTimestamp: "".concat(Date.now())
                                })
                            }, s2.label = 2;
                        case 2:
                            return s2.trys.push([
                                2,
                                4,
                                ,
                                5
                            ]), [
                                4,
                                this.publishDeviceData(r2)
                            ];
                        case 3:
                            return n2 = s2.sent(), this.fingerprintRequestId = n2, [
                                3,
                                5
                            ];
                        case 4:
                            throw i2 = s2.sent(), this.status = "error", Q(i2), o2 = nt(i2, "publishDeviceData"), this.onDataPublishFailure(o2, {
                                metrics: this.calculateMetrics()
                            }), new Error("Failure publishing device data");
                        case 5:
                            return [
                                4,
                                this.persistDeviceData({
                                    requestId: n2,
                                    sourceType: t3,
                                    cardToken: e2
                                })
                            ];
                        case 6:
                            return [
                                2,
                                {
                                    deviceSessionId: s2.sent(),
                                    fingerprintRequestId: n2
                                }
                            ];
                    }
                    var a2;
                });
            });
        }, t2.prototype.persistDeviceData = function(t3) {
            var e2 = t3.requestId, r2 = t3.sourceType, n2 = t3.cardToken;
            return P(this, void 0, void 0, function() {
                var t4, i2, o2;
                return k(this, function(s2) {
                    switch(s2.label){
                        case 0:
                            return s2.trys.push([
                                0,
                                2,
                                ,
                                3
                            ]), [
                                4,
                                this.persistFpData(e2, r2, n2)
                            ];
                        case 1:
                            return t4 = s2.sent().device_session_id, this.status = "published", this.onDataPublished({
                                riskSessionId: t4,
                                requestId: e2,
                                metrics: this.calculateMetrics()
                            }), this.deviceSessionId = t4, [
                                2,
                                t4
                            ];
                        case 2:
                            throw i2 = s2.sent(), this.status = "error", Q(i2), o2 = nt(i2, "persistDeviceData"), this.onDataPublishFailure(o2, {
                                metrics: this.calculateMetrics()
                            }), new Error("Failure persisting device data");
                        case 3:
                            return [
                                2
                            ];
                    }
                });
            });
        }, t2.prototype.persistFpData = function(t3, e2, r2) {
            return P(this, void 0, void 0, function() {
                var n2, i2, o2, s2, a2;
                return k(this, function(u2) {
                    switch(u2.label){
                        case 0:
                            n2 = new AbortController(), i2 = setTimeout(function() {
                                return n2.abort();
                            }, 5e3), u2.label = 1;
                        case 1:
                            return u2.trys.push([
                                1,
                                4,
                                5,
                                6
                            ]), o2 = performance.now(), [
                                4,
                                fetch("".concat(this.deviceDataEndpoint, "/fingerprint"), {
                                    method: "PUT",
                                    body: JSON.stringify({
                                        fp_request_id: t3,
                                        integration_type: e2 === I.CardToken ? W.RiskJsInFramesJs : W.RiskJsStandalone,
                                        card_token: e2 === I.CardToken ? r2 : null
                                    }),
                                    headers: {
                                        "Content-Type": "application/json",
                                        Accept: "application/json",
                                        Authorization: this.publicKey
                                    },
                                    signal: n2.signal
                                })
                            ];
                        case 2:
                            if (s2 = u2.sent(), a2 = performance.now(), this.deviceDataPersistTime = a2 - o2, !s2.ok) throw new $("Error! status: ".concat(s2.status), s2.status, s2);
                            return [
                                4,
                                s2.json()
                            ];
                        case 3:
                            return [
                                2,
                                u2.sent()
                            ];
                        case 4:
                            throw u2.sent();
                        case 5:
                            return clearTimeout(i2), [
                                7
                            ];
                        case 6:
                            return [
                                2
                            ];
                    }
                });
            });
        }, t2.prototype.publishDeviceData = function(t3) {
            return P(this, void 0, void 0, function() {
                var e2, r2, n2;
                return k(this, function(i2) {
                    switch(i2.label){
                        case 0:
                            return i2.trys.push([
                                0,
                                2,
                                ,
                                3
                            ]), e2 = performance.now(), [
                                4,
                                rt(this, t3)
                            ];
                        case 1:
                            return r2 = i2.sent(), n2 = performance.now(), this.fpPublishTime = n2 - e2, [
                                2,
                                r2
                            ];
                        case 2:
                            throw i2.sent();
                        case 3:
                            return [
                                2
                            ];
                    }
                });
            });
        }, t2.prototype.calculateMetrics = function() {
            var t3 = function(t4) {
                var e2 = {};
                for(var r2 in t4){
                    var n2 = t4[r2];
                    n2 && (e2[r2] = n2);
                }
                return e2;
            }({
                FpPublish: this.fpPublishTime,
                DeviceDataPersist: this.deviceDataPersistTime,
                FpLoad: this.loadTime,
                Block: this.blockTime
            });
            return O(O({}, t3), {
                Total: Object.values(t3).reduce(function(t4, e2) {
                    return t4 + e2;
                }, 0)
            });
        }, t2.prototype.createRiskCallsBlockedPromise = function(t3) {
            return P(this, void 0, void 0, function() {
                var e2 = this;
                return k(this, function(r2) {
                    return [
                        2,
                        Promise.all([
                            this.checkHealth(),
                            this.getFingerprintConfiguration({
                                integration_type: t3
                            })
                        ]).catch(function(t4) {
                            e2.status = "blocked", e2.onDataPublishBlocked(t4);
                        })
                    ];
                });
            });
        }, t2.prototype.checkHealth = function() {
            return it("".concat(this.riskEndpoint, "/health"));
        }, t2.prototype.getFingerprintConfiguration = function(t3) {
            var e2 = this, r2 = t3.integration_type;
            return it("".concat(this.deviceDataEndpoint, "/configuration?integrationType=").concat(r2), {
                headers: {
                    "Content-Type": "application/json",
                    Accept: "application/json",
                    Authorization: this.publicKey
                }
            }).then(function(t4) {
                return P(e2, void 0, void 0, function() {
                    var e3;
                    return k(this, function(r3) {
                        switch(r3.label){
                            case 0:
                                return [
                                    4,
                                    t4.json()
                                ];
                            case 1:
                                return e3 = r3.sent(), "blocked" !== this.status && (this.status = e3.fingerprint_integration.enabled ? "enabled" : "disabled"), this.fingerprintPublicKey = e3.fingerprint_integration.public_key, [
                                    2
                                ];
                        }
                    });
                });
            });
        }, t2;
    }();
    var rt = function rt(t2, e2) {
        return P(void 0, void 0, void 0, function() {
            var r2;
            return k(this, function(n2) {
                switch(n2.label){
                    case 0:
                        return null !== t2.fingerprintAgent ? [
                            3,
                            3
                        ] : [
                            4,
                            t2.loadFingerprintJS()
                        ];
                    case 1:
                        if (null === (r2 = n2.sent())) throw new Error("FingerprintJS is not loaded");
                        return [
                            4,
                            r2.get(e2)
                        ];
                    case 2:
                        return [
                            2,
                            n2.sent().requestId
                        ];
                    case 3:
                        return [
                            4,
                            t2.fingerprintAgent.get(e2)
                        ];
                    case 4:
                        return [
                            2,
                            n2.sent().requestId
                        ];
                }
            });
        });
    };
    var nt = function nt(t2, e2) {
        var r2, n2 = {
            Reason: "AbortError" === (null == t2 ? void 0 : t2.name) || "TimeoutError" === (null == t2 ? void 0 : t2.name) ? "timeout" : null == t2 ? void 0 : t2.name,
            Message: null == t2 ? void 0 : t2.message,
            Type: e2
        };
        return "object" == typeof (r2 = t2) && r2 && "message" in r2 && "code" in r2 && "response" in r2 && (n2 = {
            Reason: t2.response.statusText,
            Status: t2.response.status,
            Message: null == t2 ? void 0 : t2.message
        }), n2;
    };
    var it = function it(t2, e2) {
        return void 0 === e2 && (e2 = {}), P(void 0, void 0, void 0, function() {
            var r2;
            return k(this, function(n2) {
                switch(n2.label){
                    case 0:
                        return n2.trys.push([
                            0,
                            2,
                            ,
                            3
                        ]), [
                            4,
                            fetch(t2, e2)
                        ];
                    case 1:
                        if (!(r2 = n2.sent()).ok) throw new $("Request failed: url - ".concat(t2, ", status: ").concat(r2.status), r2.status, r2);
                        return [
                            2,
                            r2
                        ];
                    case 2:
                        throw n2.sent(), new Error("Request failed: url - ".concat(t2));
                    case 3:
                        return [
                            2
                        ];
                }
            });
        });
    };
    !function(t2) {
        t2.RiskDataCollected = "riskDataCollected", t2.RiskDataPublished = "riskDataPublished", t2.RiskDataPublishFailure = "riskDataPublishFailure", t2.RiskDataPublishBlocked = "riskDataPublishBlocked", t2.RiskDataPublishDisabled = "riskDataPublishDisabled";
    }(Z || (Z = {}));
    var ot = function() {
        function t2(t3) {
            var e2, r2 = t3.framesMode, n2 = void 0 !== r2 && r2, i2 = t3.riskEndpoint, o2 = t3.deviceDataEndpoint, s2 = t3.publicKey, a2 = this;
            this.handlers = ((e2 = {})[Z.RiskDataPublished] = [], e2[Z.RiskDataCollected] = [], e2[Z.RiskDataPublishFailure] = [], e2[Z.RiskDataPublishBlocked] = [], e2[Z.RiskDataPublishDisabled] = [], e2);
            var u2, c2, l2, h2 = [
                (u2 = et, c2 = {
                    riskEndpoint: i2,
                    deviceDataEndpoint: o2,
                    publicKey: s2,
                    framesMode: n2
                }, l2 = {
                    onDataCollected: function onDataCollected() {
                        Y(a2.handlers[Z.RiskDataCollected]);
                    },
                    onDataPublishBlocked: function onDataPublishBlocked(t4) {
                        Y(a2.handlers[Z.RiskDataPublishBlocked], t4);
                    },
                    onDataPublishFailure: function onDataPublishFailure(t4, e3) {
                        Y(a2.handlers[Z.RiskDataPublishFailure], t4, e3);
                    },
                    onDataPublished: function onDataPublished(t4) {
                        Y(a2.handlers[Z.RiskDataPublished], t4);
                    },
                    onDataDisabled: function onDataDisabled() {
                        Y(a2.handlers[Z.RiskDataPublishDisabled]);
                    }
                }, new u2(c2, l2))
            ];
            this.dataCollectorManager = new A({
                framesMode: n2,
                dataCollectors: h2
            });
        }
        return t2.prototype.addEventListener = function(t3, e2) {
            !function(t4) {
                return z(Z).map(function(t5) {
                    return Z[t5];
                }).indexOf(t4) > -1;
            }(t3) ? console.log("event not supported", t3) : this.handlers[t3].push(e2);
        }, t2.prototype.publishRiskData = function(t3) {
            return P(this, void 0, void 0, function() {
                return k(this, function(e2) {
                    return [
                        2,
                        this.dataCollectorManager.publishData(t3)
                    ];
                });
            });
        }, t2;
    }();
    var st = require_package().version;
    var at = function() {
        function t2() {}
        return t2.init = function(e2) {
            if (!e2.publicKey || !e2.riskEndpoint || !e2.deviceDataEndpoint) throw new Error("missing some of the required options for the risk sdk");
            return t2.instance || (t2.instance = new ot(e2)), t2.instance;
        }, t2;
    }();
    var risk_js_esm_default = at;
    // ../../node_modules/.pnpm/@datadog+browser-core@4.42.2/node_modules/@datadog/browser-core/esm/tools/display.js
    var ConsoleApiName = {
        log: "log",
        debug: "debug",
        info: "info",
        warn: "warn",
        error: "error"
    };
    var display = function display1(api) {
        var args = [];
        for(var _i = 1; _i < arguments.length; _i++){
            args[_i - 1] = arguments[_i];
        }
        if (!Object.prototype.hasOwnProperty.call(ConsoleApiName, api)) {
            api = ConsoleApiName.log;
        }
        display[api].apply(display, args);
    };
    var globalConsole = console;
    display.debug = globalConsole.debug.bind(globalConsole);
    display.log = globalConsole.log.bind(globalConsole);
    display.info = globalConsole.info.bind(globalConsole);
    display.warn = globalConsole.warn.bind(globalConsole);
    display.error = globalConsole.error.bind(globalConsole);
    // ../../node_modules/.pnpm/@datadog+browser-core@4.42.2/node_modules/@datadog/browser-core/esm/tools/utils/timeUtils.js
    var ONE_SECOND = 1e3;
    var ONE_MINUTE = 60 * ONE_SECOND;
    var ONE_HOUR = 60 * ONE_MINUTE;
    var ONE_DAY = 24 * ONE_HOUR;
    var ONE_YEAR = 365 * ONE_DAY;
    var navigationStart;
    // ../../node_modules/.pnpm/@datadog+browser-core@4.42.2/node_modules/@datadog/browser-core/esm/tools/utils/stringUtils.js
    function generateUUID(placeholder) {
        return placeholder ? // eslint-disable-next-line  no-bitwise
        (parseInt(placeholder, 10) ^ Math.random() * 16 >> parseInt(placeholder, 10) / 4).toString(16) : "".concat(1e7, "-").concat(1e3, "-").concat(4e3, "-").concat(8e3, "-").concat(1e11).replace(/[018]/g, generateUUID);
    }
    // ../../node_modules/.pnpm/@datadog+browser-core@4.42.2/node_modules/@datadog/browser-core/esm/browser/cookie.js
    var COOKIE_ACCESS_DELAY = ONE_SECOND;
    var getCurrentSiteCache;
    // ../../node_modules/.pnpm/@datadog+browser-core@4.42.2/node_modules/@datadog/browser-core/esm/tools/experimentalFeatures.js
    var ExperimentalFeature;
    (function(ExperimentalFeature2) {
        ExperimentalFeature2["PAGEHIDE"] = "pagehide";
        ExperimentalFeature2["FEATURE_FLAGS"] = "feature_flags";
        ExperimentalFeature2["RESOURCE_PAGE_STATES"] = "resource_page_states";
        ExperimentalFeature2["COLLECT_FLUSH_REASON"] = "collect_flush_reason";
    })(ExperimentalFeature || (ExperimentalFeature = {}));
    var enabledExperimentalFeatures = /* @__PURE__ */ new Set();
    // ../../node_modules/.pnpm/@datadog+browser-core@4.42.2/node_modules/@datadog/browser-core/esm/tools/utils/byteUtils.js
    var ONE_KIBI_BYTE = 1024;
    var ONE_MEBI_BYTE = 1024 * ONE_KIBI_BYTE;
    var HAS_MULTI_BYTES_CHARACTERS = /[^\u0000-\u007F]/;
    // ../../node_modules/.pnpm/@datadog+browser-core@4.42.2/node_modules/@datadog/browser-core/esm/tools/monitor.js
    var __spreadArray = function __spreadArray(to, from, pack) {
        if (pack || arguments.length === 2) for(var i2 = 0, l2 = from.length, ar; i2 < l2; i2++){
            if (ar || !(i2 in from)) {
                if (!ar) ar = Array.prototype.slice.call(from, 0, i2);
                ar[i2] = from[i2];
            }
        }
        return to.concat(ar || Array.prototype.slice.call(from));
    };
    var onMonitorErrorCollected;
    var debugMode = false;
    var originalURL = URL;
    var isURLSupported;
    // ../../node_modules/.pnpm/@datadog+browser-core@4.42.2/node_modules/@datadog/browser-core/esm/domain/configuration/intakeSites.js
    var INTAKE_SITE_STAGING = "datad0g.com";
    var INTAKE_SITE_US1 = "datadoghq.com";
    var INTAKE_SITE_AP1 = "ap1.datadoghq.com";
    var INTAKE_SITE_US1_FED = "ddog-gov.com";
    // ../../node_modules/.pnpm/@datadog+browser-core@4.42.2/node_modules/@datadog/browser-core/esm/domain/configuration/endpointBuilder.js
    var ENDPOINTS = {
        logs: "logs",
        rum: "rum",
        sessionReplay: "session-replay"
    };
    var INTAKE_TRACKS = {
        logs: "logs",
        rum: "rum",
        sessionReplay: "replay"
    };
    // ../../node_modules/.pnpm/@datadog+browser-core@4.42.2/node_modules/@datadog/browser-core/esm/domain/configuration/tags.js
    var TAG_SIZE_LIMIT = 200;
    var FORBIDDEN_CHARACTERS = /[^a-z0-9_:./-]/;
    // ../../node_modules/.pnpm/@datadog+browser-core@4.42.2/node_modules/@datadog/browser-core/esm/domain/tracekit/computeStackTrace.js
    var UNKNOWN_FUNCTION = "?";
    var fileUrl = "((?:file|https?|blob|chrome-extension|native|eval|webpack|snippet|<anonymous>|\\w+\\.|\\/).*?)";
    var filePosition = "(?::(\\d+))";
    var CHROME_LINE_RE = new RegExp("^\\s*at (.*?) ?\\(".concat(fileUrl).concat(filePosition, "?").concat(filePosition, "?\\)?\\s*$"), "i");
    var CHROME_EVAL_RE = new RegExp("\\((\\S*)".concat(filePosition).concat(filePosition, "\\)"));
    var CHROME_ANONYMOUS_FUNCTION_RE = new RegExp("^\\s*at ?".concat(fileUrl).concat(filePosition, "?").concat(filePosition, "??\\s*$"), "i");
    var WINJS_LINE_RE = /^\s*at (?:((?:\[object object\])?.+) )?\(?((?:file|ms-appx|https?|webpack|blob):.*?):(\d+)(?::(\d+))?\)?\s*$/i;
    var GECKO_LINE_RE = /^\s*(.*?)(?:\((.*?)\))?(?:^|@)((?:file|https?|blob|chrome|webpack|resource|capacitor|\[native).*?|[^@]*bundle)(?::(\d+))?(?::(\d+))?\s*$/i;
    var GECKO_EVAL_RE = /(\S+) line (\d+)(?: > eval line \d+)* > eval/i;
    // ../../node_modules/.pnpm/@datadog+browser-core@4.42.2/node_modules/@datadog/browser-core/esm/domain/tracekit/tracekit.js
    var ERROR_TYPES_RE = /^(?:[Uu]ncaught (?:exception: )?)?(?:((?:Eval|Internal|Range|Reference|Syntax|Type|URI|)Error): )?(.*)$/;
    // ../../node_modules/.pnpm/@datadog+browser-core@4.42.2/node_modules/@datadog/browser-core/esm/tools/serialisation/sanitize.js
    var SANITIZE_DEFAULT_MAX_CHARACTER_COUNT = 220 * ONE_KIBI_BYTE;
    var JSON_PATH_ROOT_ELEMENT = "$";
    var KEY_DECORATION_LENGTH = 3;
    // ../../node_modules/.pnpm/@datadog+browser-core@4.42.2/node_modules/@datadog/browser-core/esm/domain/error/error.js
    var NO_ERROR_STACK_PRESENT_MESSAGE = "No stack, consider using an instance of Error";
    // ../../node_modules/.pnpm/@datadog+browser-core@4.42.2/node_modules/@datadog/browser-core/esm/domain/error/error.types.js
    var ErrorSource = {
        AGENT: "agent",
        CONSOLE: "console",
        CUSTOM: "custom",
        LOGGER: "logger",
        NETWORK: "network",
        SOURCE: "source",
        REPORT: "report"
    };
    // ../../node_modules/.pnpm/@datadog+browser-core@4.42.2/node_modules/@datadog/browser-core/esm/tools/observable.js
    var Observable = /** @class */ function() {
        function Observable2(onFirstSubscribe) {
            this.onFirstSubscribe = onFirstSubscribe;
            this.observers = [];
        }
        Observable2.prototype.subscribe = function(f2) {
            var _this = this;
            if (!this.observers.length && this.onFirstSubscribe) {
                this.onLastUnsubscribe = this.onFirstSubscribe() || void 0;
            }
            this.observers.push(f2);
            return {
                unsubscribe: function unsubscribe() {
                    _this.observers = _this.observers.filter(function(other) {
                        return f2 !== other;
                    });
                    if (!_this.observers.length && _this.onLastUnsubscribe) {
                        _this.onLastUnsubscribe();
                    }
                }
            };
        };
        Observable2.prototype.notify = function(data) {
            this.observers.forEach(function(observer) {
                return observer(data);
            });
        };
        return Observable2;
    }();
    // ../../node_modules/.pnpm/@datadog+browser-core@4.42.2/node_modules/@datadog/browser-core/esm/domain/report/reportObservable.js
    var RawReportType = {
        intervention: "intervention",
        deprecation: "deprecation",
        cspViolation: "csp_violation"
    };
    // ../../node_modules/.pnpm/@datadog+browser-core@4.42.2/node_modules/@datadog/browser-core/esm/tools/mergeInto.js
    function mergeInto(destination, source, circularReferenceChecker) {
        if (circularReferenceChecker === void 0) {
            circularReferenceChecker = createCircularReferenceChecker();
        }
        if (source === void 0) {
            return destination;
        }
        if (typeof source !== "object" || source === null) {
            return source;
        } else if (_instanceof(source, Date)) {
            return new Date(source.getTime());
        } else if (_instanceof(source, RegExp)) {
            var flags = source.flags || // old browsers compatibility
            [
                source.global ? "g" : "",
                source.ignoreCase ? "i" : "",
                source.multiline ? "m" : "",
                source.sticky ? "y" : "",
                source.unicode ? "u" : ""
            ].join("");
            return new RegExp(source.source, flags);
        }
        if (circularReferenceChecker.hasAlreadyBeenSeen(source)) {
            return void 0;
        } else if (Array.isArray(source)) {
            var merged_1 = Array.isArray(destination) ? destination : [];
            for(var i2 = 0; i2 < source.length; ++i2){
                merged_1[i2] = mergeInto(merged_1[i2], source[i2], circularReferenceChecker);
            }
            return merged_1;
        }
        var merged = getType(destination) === "object" ? destination : {};
        for(var key in source){
            if (Object.prototype.hasOwnProperty.call(source, key)) {
                merged[key] = mergeInto(merged[key], source[key], circularReferenceChecker);
            }
        }
        return merged;
    }
    // ../../node_modules/.pnpm/@datadog+browser-core@4.42.2/node_modules/@datadog/browser-core/esm/domain/telemetry/rawTelemetryEvent.types.js
    var TelemetryType = {
        log: "log",
        configuration: "configuration"
    };
    // ../../node_modules/.pnpm/@datadog+browser-core@4.42.2/node_modules/@datadog/browser-core/esm/domain/telemetry/telemetry.js
    var ALLOWED_FRAME_URLS = [
        "https://www.datadoghq-browser-agent.com",
        "https://www.datad0g-browser-agent.com",
        "http://localhost",
        "<anonymous>"
    ];
    var TELEMETRY_EXCLUDED_SITES = [
        INTAKE_SITE_US1_FED
    ];
    var telemetryConfiguration = {
        maxEventsPerPage: 0,
        sentEventCount: 0,
        telemetryEnabled: false,
        telemetryConfigurationEnabled: false
    };
    var onRawTelemetryEventCollected;
    // ../../node_modules/.pnpm/@datadog+browser-core@4.42.2/node_modules/@datadog/browser-core/esm/tools/valueHistory.js
    var END_OF_TIMES = Infinity;
    var CLEAR_OLD_VALUES_INTERVAL = ONE_MINUTE;
    var ValueHistory = /** @class */ function() {
        function ValueHistory2(expireDelay) {
            var _this = this;
            this.expireDelay = expireDelay;
            this.entries = [];
            this.clearOldValuesInterval = setInterval(function() {
                return _this.clearOldValues();
            }, CLEAR_OLD_VALUES_INTERVAL);
        }
        ValueHistory2.prototype.add = function(value, startTime) {
            var _this = this;
            var entry = {
                value: value,
                startTime: startTime,
                endTime: END_OF_TIMES,
                remove: function remove() {
                    var index = _this.entries.indexOf(entry);
                    if (index >= 0) {
                        _this.entries.splice(index, 1);
                    }
                },
                close: function close(endTime) {
                    entry.endTime = endTime;
                }
            };
            this.entries.unshift(entry);
            return entry;
        };
        ValueHistory2.prototype.find = function(startTime) {
            if (startTime === void 0) {
                startTime = END_OF_TIMES;
            }
            for(var _i = 0, _a4 = this.entries; _i < _a4.length; _i++){
                var entry = _a4[_i];
                if (entry.startTime <= startTime) {
                    if (startTime <= entry.endTime) {
                        return entry.value;
                    }
                    break;
                }
            }
        };
        ValueHistory2.prototype.closeActive = function(endTime) {
            var latestEntry = this.entries[0];
            if (latestEntry && latestEntry.endTime === END_OF_TIMES) {
                latestEntry.close(endTime);
            }
        };
        ValueHistory2.prototype.findAll = function(startTime) {
            if (startTime === void 0) {
                startTime = END_OF_TIMES;
            }
            return this.entries.filter(function(entry) {
                return entry.startTime <= startTime && startTime <= entry.endTime;
            }).map(function(entry) {
                return entry.value;
            });
        };
        ValueHistory2.prototype.reset = function() {
            this.entries = [];
        };
        ValueHistory2.prototype.stop = function() {
            clearInterval(this.clearOldValuesInterval);
        };
        ValueHistory2.prototype.clearOldValues = function() {
            var oldTimeThreshold = relativeNow() - this.expireDelay;
            while(this.entries.length > 0 && this.entries[this.entries.length - 1].endTime < oldTimeThreshold){
                this.entries.pop();
            }
        };
        return ValueHistory2;
    }();
    // ../../node_modules/.pnpm/@datadog+browser-core@4.42.2/node_modules/@datadog/browser-core/esm/domain/session/sessionConstants.js
    var SESSION_TIME_OUT_DELAY = 4 * ONE_HOUR;
    var SESSION_EXPIRATION_DELAY = 15 * ONE_MINUTE;
    // ../../node_modules/.pnpm/@datadog+browser-core@4.42.2/node_modules/@datadog/browser-core/esm/domain/session/sessionCookieStore.js
    var SESSION_ENTRY_REGEXP = /^([a-z]+)=([a-z0-9-]+)$/;
    var SESSION_ENTRY_SEPARATOR = "&";
    var SESSION_COOKIE_NAME = "_dd_s";
    var LOCK_RETRY_DELAY = 10;
    var MAX_NUMBER_OF_LOCK_RETRIES = 100;
    var bufferedOperations = [];
    var ongoingOperations;
    // ../../node_modules/.pnpm/@datadog+browser-core@4.42.2/node_modules/@datadog/browser-core/esm/domain/session/oldCookiesMigration.js
    var OLD_SESSION_COOKIE_NAME = "_dd";
    var OLD_RUM_COOKIE_NAME = "_dd_r";
    var OLD_LOGS_COOKIE_NAME = "_dd_l";
    var RUM_SESSION_KEY = "rum";
    var LOGS_SESSION_KEY = "logs";
    // ../../node_modules/.pnpm/@datadog+browser-core@4.42.2/node_modules/@datadog/browser-core/esm/domain/session/sessionManager.js
    var VISIBILITY_CHECK_DELAY = ONE_MINUTE;
    var SESSION_CONTEXT_TIMEOUT_DELAY = SESSION_TIME_OUT_DELAY;
    var stopCallbacks = [];
    // ../../node_modules/.pnpm/@datadog+browser-core@4.42.2/node_modules/@datadog/browser-core/esm/transport/sendWithRetryStrategy.js
    var MAX_ONGOING_BYTES_COUNT = 80 * ONE_KIBI_BYTE;
    var MAX_ONGOING_REQUESTS = 32;
    var MAX_QUEUE_BYTES_COUNT = 3 * ONE_MEBI_BYTE;
    var MAX_BACKOFF_TIME = ONE_MINUTE;
    var INITIAL_BACKOFF_TIME = ONE_SECOND;
    function scheduleRetry(state, sendStrategy, endpointType, reportError) {
        if (state.transportStatus !== 2) {
            return;
        }
        setTimeout2(function() {
            var payload = state.queuedPayloads.first();
            send(payload, state, sendStrategy, {
                onSuccess: function onSuccess() {
                    state.queuedPayloads.dequeue();
                    state.currentBackoffTime = INITIAL_BACKOFF_TIME;
                    retryQueuedPayloads(1, state, sendStrategy, endpointType, reportError);
                },
                onFailure: function onFailure() {
                    state.currentBackoffTime = Math.min(MAX_BACKOFF_TIME, state.currentBackoffTime * 2);
                    scheduleRetry(state, sendStrategy, endpointType, reportError);
                }
            });
        }, state.currentBackoffTime);
    }
    var hasReportedBeaconError = false;
    // ../../node_modules/.pnpm/@datadog+browser-core@4.42.2/node_modules/@datadog/browser-core/esm/browser/pageExitObservable.js
    var PageExitReason = {
        HIDDEN: "visibility_hidden",
        UNLOADING: "before_unload",
        PAGEHIDE: "page_hide",
        FROZEN: "page_frozen"
    };
    // ../../node_modules/.pnpm/@datadog+browser-core@4.42.2/node_modules/@datadog/browser-core/esm/transport/batch.js
    var Batch = /** @class */ function() {
        function Batch2(request, flushController, messageBytesLimit) {
            var _this = this;
            this.request = request;
            this.flushController = flushController;
            this.messageBytesLimit = messageBytesLimit;
            this.pushOnlyBuffer = [];
            this.upsertBuffer = {};
            this.flushController.flushObservable.subscribe(function(event) {
                return _this.flush(event);
            });
        }
        Batch2.prototype.add = function(message) {
            this.addOrUpdate(message);
        };
        Batch2.prototype.upsert = function(message, key) {
            this.addOrUpdate(message, key);
        };
        Batch2.prototype.flush = function(event) {
            var messages = this.pushOnlyBuffer.concat(objectValues(this.upsertBuffer));
            this.pushOnlyBuffer = [];
            this.upsertBuffer = {};
            var payload = {
                data: messages.join("\n"),
                bytesCount: event.bytesCount,
                flushReason: event.reason
            };
            if (isPageExitReason(event.reason)) {
                this.request.sendOnExit(payload);
            } else {
                this.request.send(payload);
            }
        };
        Batch2.prototype.addOrUpdate = function(message, key) {
            var _a4 = this.process(message), processedMessage = _a4.processedMessage, messageBytesCount = _a4.messageBytesCount;
            if (messageBytesCount >= this.messageBytesLimit) {
                display.warn("Discarded a message whose size was bigger than the maximum allowed size ".concat(this.messageBytesLimit, "KB."));
                return;
            }
            if (this.hasMessageFor(key)) {
                this.remove(key);
            }
            this.push(processedMessage, messageBytesCount, key);
        };
        Batch2.prototype.process = function(message) {
            var processedMessage = jsonStringify(message);
            var messageBytesCount = computeBytesCount(processedMessage);
            return {
                processedMessage: processedMessage,
                messageBytesCount: messageBytesCount
            };
        };
        Batch2.prototype.push = function(processedMessage, messageBytesCount, key) {
            var separatorBytesCount = this.flushController.messagesCount > 0 ? 1 : 0;
            this.flushController.notifyBeforeAddMessage(messageBytesCount + separatorBytesCount);
            if (key !== void 0) {
                this.upsertBuffer[key] = processedMessage;
            } else {
                this.pushOnlyBuffer.push(processedMessage);
            }
            this.flushController.notifyAfterAddMessage();
        };
        Batch2.prototype.remove = function(key) {
            var removedMessage = this.upsertBuffer[key];
            delete this.upsertBuffer[key];
            var messageBytesCount = computeBytesCount(removedMessage);
            var separatorBytesCount = this.flushController.messagesCount > 1 ? 1 : 0;
            this.flushController.notifyAfterRemoveMessage(messageBytesCount + separatorBytesCount);
        };
        Batch2.prototype.hasMessageFor = function(key) {
            return key !== void 0 && this.upsertBuffer[key] !== void 0;
        };
        return Batch2;
    }();
    // ../../node_modules/.pnpm/@datadog+browser-core@4.42.2/node_modules/@datadog/browser-core/esm/tools/abstractLifeCycle.js
    var AbstractLifeCycle = /** @class */ function() {
        function AbstractLifeCycle2() {
            this.callbacks = {};
        }
        AbstractLifeCycle2.prototype.notify = function(eventType, data) {
            var eventCallbacks = this.callbacks[eventType];
            if (eventCallbacks) {
                eventCallbacks.forEach(function(callback) {
                    return callback(data);
                });
            }
        };
        AbstractLifeCycle2.prototype.subscribe = function(eventType, callback) {
            var _this = this;
            if (!this.callbacks[eventType]) {
                this.callbacks[eventType] = [];
            }
            this.callbacks[eventType].push(callback);
            return {
                unsubscribe: function unsubscribe() {
                    _this.callbacks[eventType] = _this.callbacks[eventType].filter(function(other) {
                        return callback !== other;
                    });
                }
            };
        };
        return AbstractLifeCycle2;
    }();
    // ../../node_modules/.pnpm/@datadog+browser-core@4.42.2/node_modules/@datadog/browser-core/esm/browser/xhrObservable.js
    var xhrObservable;
    var xhrContexts = /* @__PURE__ */ new WeakMap();
    // ../../node_modules/.pnpm/@datadog+browser-core@4.42.2/node_modules/@datadog/browser-core/esm/browser/fetchObservable.js
    var fetchObservable;
    // ../../node_modules/.pnpm/@datadog+browser-core@4.42.2/node_modules/@datadog/browser-core/esm/domain/console/consoleObservable.js
    var consoleObservablesByApi = {};
    // ../../node_modules/.pnpm/@datadog+browser-core@4.42.2/node_modules/@datadog/browser-core/esm/tools/boundedBuffer.js
    var BUFFER_LIMIT = 500;
    var BoundedBuffer = /** @class */ function() {
        function BoundedBuffer2() {
            this.buffer = [];
        }
        BoundedBuffer2.prototype.add = function(callback) {
            var length = this.buffer.push(callback);
            if (length > BUFFER_LIMIT) {
                this.buffer.splice(0, 1);
            }
        };
        BoundedBuffer2.prototype.drain = function() {
            this.buffer.forEach(function(callback) {
                return callback();
            });
            this.buffer.length = 0;
        };
        return BoundedBuffer2;
    }();
    // ../../node_modules/.pnpm/@datadog+browser-core@4.42.2/node_modules/@datadog/browser-core/esm/tools/serialisation/heavyCustomerDataWarning.js
    var CUSTOMER_DATA_BYTES_LIMIT = 3 * ONE_KIBI_BYTE;
    // ../../node_modules/.pnpm/@datadog+browser-core@4.42.2/node_modules/@datadog/browser-core/esm/tools/serialisation/contextManager.js
    var BYTES_COMPUTATION_THROTTLING_DELAY = 200;
    // ../../node_modules/.pnpm/@datadog+browser-core@4.42.2/node_modules/@datadog/browser-core/esm/domain/synthetics/syntheticsWorkerValues.js
    var SYNTHETICS_TEST_ID_COOKIE_NAME = "datadog-synthetics-public-id";
    var SYNTHETICS_RESULT_ID_COOKIE_NAME = "datadog-synthetics-result-id";
    var SYNTHETICS_INJECTS_RUM_COOKIE_NAME = "datadog-synthetics-injects-rum";
    // ../../node_modules/.pnpm/@datadog+browser-logs@4.42.2/node_modules/@datadog/browser-logs/esm/domain/configuration.js
    var DEFAULT_REQUEST_ERROR_RESPONSE_LENGTH_LIMIT = 32 * ONE_KIBI_BYTE;
    // ../../node_modules/.pnpm/@datadog+browser-logs@4.42.2/node_modules/@datadog/browser-logs/esm/domain/logger.js
    var __decorate = function __decorate(decorators, target, key, desc) {
        var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d2;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r2 = Reflect.decorate(decorators, target, key, desc);
        else for(var i2 = decorators.length - 1; i2 >= 0; i2--)if (d2 = decorators[i2]) r2 = (c2 < 3 ? d2(r2) : c2 > 3 ? d2(target, key, r2) : d2(target, key)) || r2;
        return c2 > 3 && r2 && Object.defineProperty(target, key, r2), r2;
    };
    var StatusType = {
        debug: "debug",
        error: "error",
        info: "info",
        warn: "warn"
    };
    var HandlerType = {
        console: "console",
        http: "http",
        silent: "silent"
    };
    var STATUSES = Object.keys(StatusType);
    var Logger = /** @class */ function() {
        function Logger2(handleLogStrategy, name, handlerType, level, loggerContext) {
            if (handlerType === void 0) {
                handlerType = HandlerType.http;
            }
            if (level === void 0) {
                level = StatusType.debug;
            }
            if (loggerContext === void 0) {
                loggerContext = {};
            }
            this.handleLogStrategy = handleLogStrategy;
            this.handlerType = handlerType;
            this.level = level;
            this.contextManager = createContextManager("logger context");
            this.contextManager.set(assign({}, loggerContext, name ? {
                logger: {
                    name: name
                }
            } : void 0));
        }
        Logger2.prototype.log = function(message, messageContext, status, error) {
            if (status === void 0) {
                status = StatusType.info;
            }
            var errorContext;
            if (status === StatusType.error) {
                errorContext = {
                    origin: ErrorSource.LOGGER
                };
            }
            if (error !== void 0 && error !== null) {
                var stackTrace = _instanceof(error, Error) ? computeStackTrace(error) : void 0;
                var rawError = computeRawError({
                    stackTrace: stackTrace,
                    originalError: error,
                    nonErrorPrefix: "Provided",
                    source: ErrorSource.LOGGER,
                    handling: "handled",
                    startClocks: clocksNow()
                });
                errorContext = {
                    origin: ErrorSource.LOGGER,
                    stack: rawError.stack,
                    kind: rawError.type,
                    message: rawError.message
                };
            }
            var sanitizedMessageContext = sanitize(messageContext);
            var context = errorContext ? combine({
                error: errorContext
            }, sanitizedMessageContext) : sanitizedMessageContext;
            this.handleLogStrategy({
                message: sanitize(message),
                context: context,
                status: status
            }, this);
        };
        Logger2.prototype.debug = function(message, messageContext, error) {
            this.log(message, messageContext, StatusType.debug, error);
        };
        Logger2.prototype.info = function(message, messageContext, error) {
            this.log(message, messageContext, StatusType.info, error);
        };
        Logger2.prototype.warn = function(message, messageContext, error) {
            this.log(message, messageContext, StatusType.warn, error);
        };
        Logger2.prototype.error = function(message, messageContext, error) {
            this.log(message, messageContext, StatusType.error, error);
        };
        Logger2.prototype.setContext = function(context) {
            this.contextManager.set(context);
        };
        Logger2.prototype.getContext = function() {
            return this.contextManager.get();
        };
        Logger2.prototype.addContext = function(key, value) {
            this.contextManager.add(key, value);
        };
        Logger2.prototype.removeContext = function(key) {
            this.contextManager.remove(key);
        };
        Logger2.prototype.setHandler = function(handler) {
            this.handlerType = handler;
        };
        Logger2.prototype.getHandler = function() {
            return this.handlerType;
        };
        Logger2.prototype.setLevel = function(level) {
            this.level = level;
        };
        Logger2.prototype.getLevel = function() {
            return this.level;
        };
        __decorate([
            monitored
        ], Logger2.prototype, "log", null);
        return Logger2;
    }();
    // ../../node_modules/.pnpm/@datadog+browser-logs@4.42.2/node_modules/@datadog/browser-logs/esm/domain/logsSessionManager.js
    var LOGS_SESSION_KEY2 = "logs";
    // ../../node_modules/.pnpm/@datadog+browser-logs@4.42.2/node_modules/@datadog/browser-logs/esm/domain/logsCollection/logger/loggerCollection.js
    var _a;
    var STATUS_PRIORITIES = (_a = {}, _a[StatusType.debug] = 0, _a[StatusType.info] = 1, _a[StatusType.warn] = 2, _a[StatusType.error] = 3, _a);
    var logsSentBeforeRumInjectionTelemetryAdded = false;
    // ../../node_modules/.pnpm/@datadog+browser-logs@4.42.2/node_modules/@datadog/browser-logs/esm/domain/logsCollection/console/consoleCollection.js
    var _a2;
    var LogStatusForApi = (_a2 = {}, _a2[ConsoleApiName.log] = StatusType.info, _a2[ConsoleApiName.debug] = StatusType.debug, _a2[ConsoleApiName.info] = StatusType.info, _a2[ConsoleApiName.warn] = StatusType.warn, _a2[ConsoleApiName.error] = StatusType.error, _a2);
    // ../../node_modules/.pnpm/@datadog+browser-logs@4.42.2/node_modules/@datadog/browser-logs/esm/domain/logsCollection/report/reportCollection.js
    var _a3;
    var LogStatusForReport = (_a3 = {}, _a3[RawReportType.cspViolation] = StatusType.error, _a3[RawReportType.intervention] = StatusType.error, _a3[RawReportType.deprecation] = StatusType.warn, _a3);
    // ../../node_modules/.pnpm/@datadog+browser-logs@4.42.2/node_modules/@datadog/browser-logs/esm/domain/lifeCycle.js
    var LifeCycle = AbstractLifeCycle;
    // ../../node_modules/.pnpm/@datadog+browser-logs@4.42.2/node_modules/@datadog/browser-logs/esm/entries/main.js
    var datadogLogs = makeLogsPublicApi(startLogs);
    defineGlobal(getGlobalObject(), "DD_LOGS", datadogLogs);
    // src/logger.ts
    var extractPublicKeyParts = function(publicKey) {
        var index = publicKey.lastIndexOf("_");
        if (index === -1) {
            throw new Error("Not a valid public key");
        }
        var keyId = publicKey.slice(0, index);
        var key = publicKey.slice(index + 1);
        return {
            keyId: keyId,
            key: key
        };
    };
    var maskPublicKey = function(publicKey) {
        var _extractPublicKeyParts = extractPublicKeyParts(publicKey), keyId = _extractPublicKeyParts.keyId, key = _extractPublicKeyParts.key;
        var charcount = 5;
        var maskedKey = "".concat(key.substring(0, charcount)).concat("*".repeat(key.length - charcount * 2)).concat(key.substring(key.length - charcount));
        return "".concat(keyId, "_").concat(maskedKey);
    };
    var attachLoggerToRiskEvents = function(riskInstance, publicKey) {
        var maskedPublicKey = maskPublicKey(publicKey);
        datadogLogs.init({
            clientToken: "pubf1518f9fba0a576a86da5bf838fe29a1",
            site: "datadoghq.com",
            service: "prism.risk.js",
            forwardErrorsToLogs: false,
            sessionSampleRate: 100,
            env: "prod",
            version: "1.4.4"
        });
        var failureHandler = function(ErrorDetails, param) {
            var metrics = param.metrics;
            datadogLogs.logger.error(createLogMessage(Z.RiskDataPublishFailure, maskedPublicKey), createLogTags(Z.RiskDataPublishFailure, maskedPublicKey, {
                Error: _object_spread({}, ErrorDetails),
                Elapsed: metrics
            }));
        };
        riskInstance.addEventListener(Z.RiskDataPublishFailure, failureHandler);
        var blockHandler = function(error) {
            var Error2 = {
                Message: (error === null || error === void 0 ? void 0 : error.message) || "Unknown error"
            };
            datadogLogs.logger.error(createLogMessage(Z.RiskDataPublishBlocked, maskedPublicKey), createLogTags(Z.RiskDataPublishBlocked, maskedPublicKey, {
                Error: Error2
            }));
        };
        riskInstance.addEventListener(Z.RiskDataPublishBlocked, blockHandler);
        var disabledHandler = function(error) {
            var Error2 = {
                Message: (error === null || error === void 0 ? void 0 : error.message) || "Feature flag disabled"
            };
            datadogLogs.logger.error(createLogMessage(Z.RiskDataPublishDisabled, maskedPublicKey), createLogTags(Z.RiskDataPublishDisabled, maskedPublicKey, {
                Error: Error2
            }));
        };
        riskInstance.addEventListener(Z.RiskDataPublishDisabled, disabledHandler);
        var publishedHandler = function(param) {
            var riskSessionId = param.riskSessionId, requestId = param.requestId, metrics = param.metrics;
            datadogLogs.logger.info(createLogMessage(Z.RiskDataPublished, maskedPublicKey), createLogTags(Z.RiskDataPublished, maskedPublicKey, {
                DeviceSessionId: riskSessionId,
                RequestId: requestId,
                Elapsed: metrics
            }));
        };
        riskInstance.addEventListener(Z.RiskDataPublished, publishedHandler);
    };
    var createLogMessage = function(event, maskedPublicKey) {
        return "EventType: ".concat(event, ", MaskedPublicKey: ").concat(maskedPublicKey);
    };
    var createLogTags = function(EventType, MaskedPublicKey) {
        var additionalProperties = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
        return {
            Properties: _object_spread({
                EventType: EventType,
                MaskedPublicKey: MaskedPublicKey,
                RiskSDKVersion: st
            }, additionalProperties)
        };
    };
    // src/risk.ts
    var Risk = /*#__PURE__*/ function() {
        function Risk1() {
            _class_call_check(this, Risk1);
        }
        _create_class(Risk1, null, [
            {
                key: "init",
                value: function init(publicKey) {
                    if (!publicKey) {
                        throw new Error("Risk.js requires a public key");
                    }
                    if (!Risk.instance) {
                        Risk.instance = risk_js_esm_default.init({
                            riskEndpoint: "https://fpjs.checkout.com",
                            deviceDataEndpoint: "https://risk.checkout.com/collect",
                            framesMode: false,
                            publicKey: publicKey
                        });
                        var env = "prod";
                        if (env !== "local") {
                            attachLoggerToRiskEvents(Risk.instance, publicKey);
                        }
                    }
                    return Risk.instance;
                }
            }
        ]);
        return Risk1;
    }();
    window.Risk = Risk;
})();
